<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙在唐朝的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-23T05:39:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tangyiwu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2016/08/23/makedown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/08/23/makedown学习笔记/</id>
    <published>2016-08-23T05:39:16.000Z</published>
    <updated>2016-08-23T05:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-标题"><a href="#0x01-标题" class="headerlink" title="0x01 标题"></a>0x01 标题</h2><hr>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h2 id="0x10-无序列表"><a href="#0x10-无序列表" class="headerlink" title="0x10 无序列表"></a>0x10 无序列表</h2><hr>
<ul>
<li>无须列表1</li>
<li>无须列表2</li>
<li>无须列表3</li>
</ul>
<h2 id="0x11-有序列表"><a href="#0x11-有序列表" class="headerlink" title="0x11 有序列表"></a>0x11 有序列表</h2><hr>
<ol>
<li>《数据结构》</li>
<li>《操作系统》</li>
<li>《计算机网络》</li>
<li>《计算机组成原理》</li>
</ol>
<h2 id="0x0100-链接和图片"><a href="#0x0100-链接和图片" class="headerlink" title="0x0100 链接和图片"></a>0x0100 链接和图片</h2><hr>
<p><a href="http://www.jianshu.com" target="_blank" rel="external">简书</a></p>
<p><img src="http://latex.codecogs.com/gif.latex?\prod%20\(n_{i}\)+1" alt="图1"></p>
<h2 id="0x0101-表格1"><a href="#0x0101-表格1" class="headerlink" title="0x0101 表格1"></a>0x0101 表格1</h2><hr>
<table>
<thead>
<tr>
<th style="text-align:center">Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td style="text-align:center">col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td style="text-align:center">zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h2 id="0x0110-表格2"><a href="#0x0110-表格2" class="headerlink" title="0x0110 表格2"></a>0x0110 表格2</h2><hr>
<table>
<thead>
<tr>
<th>dog</th>
<th>bird</th>
<th>cat</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>foo</td>
<td>foo</td>
</tr>
<tr>
<td>bar</td>
<td>bar</td>
<td>bar</td>
</tr>
<tr>
<td>baz</td>
<td>baz</td>
<td>baz</td>
</tr>
</tbody>
</table>
<h2 id="0x0111-引用"><a href="#0x0111-引用" class="headerlink" title="0x0111 引用"></a>0x0111 引用</h2><hr>
<blockquote>
<p>人固有一死，或重于泰山，或轻于鸿毛</p>
</blockquote>
<h2 id="0x1000-粗体-amp-斜体"><a href="#0x1000-粗体-amp-斜体" class="headerlink" title="0x1000 粗体&amp;斜体"></a>0x1000 粗体&amp;斜体</h2><hr>
<p>学习Word的 <strong>粗体</strong> 和 <em>斜体</em> 的使用.</p>
<h2 id="0x1001-分割线"><a href="#0x1001-分割线" class="headerlink" title="0x1001 分割线"></a>0x1001 分割线</h2><hr>
<hr>
<hr>
<h2 id="0x1010-Code"><a href="#0x1010-Code" class="headerlink" title="0x1010 Code"></a>0x1010 Code</h2><hr>
<p><code>while(1)
    print(&#39;666666&#39;)</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-标题&quot;&gt;&lt;a href=&quot;#0x01-标题&quot; class=&quot;headerlink&quot; title=&quot;0x01 标题&quot;&gt;&lt;/a&gt;0x01 标题&lt;/h2&gt;&lt;hr&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>View绘制原理</title>
    <link href="http://yoursite.com/2016/08/09/View%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2016/08/09/View绘制原理/</id>
    <published>2016-08-09T02:52:03.000Z</published>
    <updated>2016-08-09T03:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  看过许多讲Android View绘制原理的博客，也写过许多自定义View，但一直感觉停留在了解、使用的程度，只是有个大流程的理解。我们都知道View的绘制原理主要有3大步:Measure-&gt;Layout-&gt;Draw。网络上有许多技术大牛对这个有着非常深入的讲解，看别人写的博客，有的地方总是难以理解或者比较抽象，而且看过后，过了一段时间，又会忘了许多细节的地方，因此，这几天把View绘制流程的源码仔细过了一边，重新捋一下。</p>
<a id="more"></a>
<h2 id="measure流程"><a href="#measure流程" class="headerlink" title="measure流程"></a>measure流程</h2><p>  View的绘制从ViewRootImpl中的performTraversals()方法开始，当需要执行measure流程的时候：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">if (!mStopped || mReportNextDraw) &#123;</div><div class="line">              boolean focusChangedDueToTouchMode = ensureTouchModeLocally(</div><div class="line">                      (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);</div><div class="line">              if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</div><div class="line">                      || mHeight != host.getMeasuredHeight() || contentInsetsChanged) &#123;</div><div class="line">                  int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line">                  int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line"></div><div class="line">                  if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed!  mWidth=&quot;</div><div class="line">                          + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth()</div><div class="line">                          + &quot; mHeight=&quot; + mHeight</div><div class="line">                          + &quot; measuredHeight=&quot; + host.getMeasuredHeight()</div><div class="line">                          + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged);</div><div class="line"></div><div class="line">                   // 询问要绘制的View想要多大</div><div class="line">                  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line"></div><div class="line">                  // Implementation of weights from WindowManager.LayoutParams</div><div class="line">                  // We just grow the dimensions as needed and re-measure if</div><div class="line">                  // needs be</div><div class="line">                  int width = host.getMeasuredWidth();</div><div class="line">                  int height = host.getMeasuredHeight();</div><div class="line">                  boolean measureAgain = false;</div><div class="line"></div><div class="line">                  if (lp.horizontalWeight &gt; 0.0f) &#123;</div><div class="line">                      width += (int) ((mWidth - width) * lp.horizontalWeight);</div><div class="line">                      childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</div><div class="line">                              MeasureSpec.EXACTLY);</div><div class="line">                      measureAgain = true;</div><div class="line">                  &#125;</div><div class="line">                  if (lp.verticalWeight &gt; 0.0f) &#123;</div><div class="line">                      height += (int) ((mHeight - height) * lp.verticalWeight);</div><div class="line">                      childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</div><div class="line">                              MeasureSpec.EXACTLY);</div><div class="line">                      measureAgain = true;</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  if (measureAgain) &#123;</div><div class="line">                      if (DEBUG_LAYOUT) Log.v(TAG,</div><div class="line">                              &quot;And hey let&apos;s measure once more: width=&quot; + width</div><div class="line">                              + &quot; height=&quot; + height);</div><div class="line">                      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  layoutRequested = true;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>  这里可以得到以下几点信息：</p>
<ol>
<li>measure从performMeasure()方法开始</li>
<li>measure可能执行两次，当我们给View设置Weight时就会执行两次，例如LinearLayout设置Weight时，就会执行两次。</li>
</ol>
<p>下面看一下performMeasure()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</div><div class="line">        try &#123;</div><div class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">        &#125; finally &#123;</div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>  mView就是整个布局里面的Root View，熟悉的人都知道Android Activity里面的Root View是叫DecorView，实际上是一个FrameLayout。<br>  进入measure方法，这个方法的初始实现是在View这个类里面，我们知道所有其他控件类或直接或间接继承这个类。View的measure()方法的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">        // Suppress sign extension for the low bytes</div><div class="line">        long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</div><div class="line">        if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</div><div class="line"></div><div class="line">        if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">            // first clears the measured dimension flag</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">            resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">            int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :</div><div class="line">                    mMeasureCache.indexOfKey(key);</div><div class="line">            if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</div><div class="line">                // measure ourselves, this should set the measured dimension flag back</div><div class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125; else &#123;</div><div class="line">                long value = mMeasureCache.valueAt(cacheIndex);</div><div class="line">                // Casting a long to int drops the high 32 bits, no mask needed</div><div class="line">                setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</div><div class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // flag not set, setMeasuredDimension() was not invoked, we raise</div><div class="line">            // an exception to warn the developer</div><div class="line">            if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">                throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;</div><div class="line">                        + getClass().getName() + &quot;#onMeasure() did not set the&quot;</div><div class="line">                        + &quot; measured dimension by calling&quot;</div><div class="line">                        + &quot; setMeasuredDimension()&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">        mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |</div><div class="line">                (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</div><div class="line">        mMeasuredWidth = measuredWidth;</div><div class="line">        mMeasuredHeight = measuredHeight;</div><div class="line"></div><div class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码告诉我们以下信息：；</p>
<ol>
<li>measure流程使用了缓存机制，缓存机制通过key-value存取，key是一个Long类型的数据，其中高32位存储View的宽度信息，低32位存储View的高度信息；</li>
<li>View的真正measure步骤是在onMeasure()方法里；</li>
<li>只有标志位是PFLAG_FORCE_LAYOUT或者View的宽高发生变化，才会真正执行measure流程；</li>
<li>当强制重新绘制(设置标志位PFLAG_FORCE_LAYOUT)或者忽略缓存（Android api版本小于19，即Android 4.4版本以下）时，才会在onMeasure()方法里面进行真正的measure流程；</li>
<li>在onMeasure()方法执行结束后需要调用setMeasuredDimension()方法，重新保存新的宽高信息，setMeasuredDimension()方法里面实际上真正最后执行到setMeasuredDimensionRaw()方法里面，并且设置标志位PFLAG_MEASURED_DIMENSION_SET，代表已经重新设置测量值了。</li>
<li>如果执行了onMeasure()方法，设置PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT标志位，代表已经measure过了，否则去掉这个标志位，这个标志位在layout流程中有用。</li>
<li>使用缓存时，直接取上一次绘制后的值，并且直接调用setMeasuredDimensionRaw()给宽高重新设置。</li>
<li>如果measure过了，设置标志位PFLAG_LAYOUT_REQUIRED，注意measure分两种，一种在onMeasure()方法里重新测量，一种使用缓存。</li>
</ol>
<h2 id="layout流程"><a href="#layout流程" class="headerlink" title="layout流程"></a>layout流程</h2><h2 id="draw流程"><a href="#draw流程" class="headerlink" title="draw流程"></a>draw流程</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  看过许多讲Android View绘制原理的博客，也写过许多自定义View，但一直感觉停留在了解、使用的程度，只是有个大流程的理解。我们都知道View的绘制原理主要有3大步:Measure-&amp;gt;Layout-&amp;gt;Draw。网络上有许多技术大牛对这个有着非常深入的讲解，看别人写的博客，有的地方总是难以理解或者比较抽象，而且看过后，过了一段时间，又会忘了许多细节的地方，因此，这几天把View绘制流程的源码仔细过了一边，重新捋一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>插件化-apk编译过程概述(公司技术分享)</title>
    <link href="http://yoursite.com/2016/07/23/%E6%8F%92%E4%BB%B6%E5%8C%96-apk%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2016/07/23/插件化-apk编译过程概述/</id>
    <published>2016-07-23T07:19:39.000Z</published>
    <updated>2016-08-22T02:52:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插件化-Apk编译过程概述"><a href="#插件化-Apk编译过程概述" class="headerlink" title="插件化-Apk编译过程概述"></a>插件化-Apk编译过程概述</h2><p>###0x00</p>
<p>大致的看了一下目前插件化的开源实现，或多或少都会对Apk的编译过程做出改动，因此尝试分析了一下Apk的打包过程。一个Apk文件实际上就是一个zip压缩包，我们把一个Apk解压后，里面的内容类似下图。</p>
<p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-6-23/97858102.jpg" alt=""></p>
<p>里面每个文件是什么含义，我们待会再看。那么，如何生成一个Apk文件呢？通常情况下，我们使用一些构建工具来编译我们的工程，例如古老的Ant，maven，我们正在使用的gradle，以及更加黑科技的buck等，但是，这些构建工具并不直接作用于编译过程，打开sdk中的build-tools目录，如下</p>
<p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-6-23/38695044.jpg" alt=""></p>
<p>这些就是google为我们提供的工具，通过它们，我们得以将代码编译成Apk，构建工具只是这些的工具的封装。</p>
<p>###0x01 HelloWorld</p>
<p>下面我们来尝试手动编译一个最简单的Apk。开始之前，先简单介绍一下我们要使用的工具。</p>
<ol>
<li>aapt[Android Asset Packaging Tool]这个工具主要帮助我们处理资源文件，以及创建，更新，查看一个Apk文件。</li>
<li>dx，这个工具帮助我们把.class文件转换成一个dex文件，dex[Dalvik Executable]文件就是Dalvik虚拟机的可执行文件，这个文件的具体格式稍后会做简单的介绍。</li>
<li>zipalign，这个工具用来优化我们生成的apk文件，它将资源文件进行4字节对齐，当资源文件映射进内存时，对齐到4字节边界可以加快资源文件的访问速度。</li>
</ol>
<p>还有两个我们使用的工具并没有出现这里，而是存在于JDK中。</p>
<ol>
<li>javac,很常用的工具，用来将java源码文件编译成字节码文件</li>
<li>keytool，创建签名的工具 </li>
<li>jarsigner，用来对生成的apk进行签名的工具</li>
</ol>
<p>下面我们来开始编译helloWorld，首先我们编写了一个最简单的Apk。</p>
<p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-6-23/51680697.jpg" alt=""></p>
<p>这个工程只有一个Activity,并且不依赖任何库。</p>
<p><strong>Step 1: 生成R.java文件</strong></p>
<p>R.java是我们访问资源的必需品，R文件是一个普通的类，其中根据资源的类型有不同的静态内部类，每个静态内部类中的静态常量分别定义一条资源标示符，这个类并不是我们编写的而是由aapt工具生成的。<br>在工程的根目录，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">aapt package \   #打包资源文件</div><div class="line">-f \             #强制覆盖已有文件</div><div class="line">-m \             #使R文件在-J参数指定的位置生成</div><div class="line">-S res \         #资源目录</div><div class="line">-J gen \         #R.java的位置</div><div class="line">-I $ANDROID_HOME/platforms/android-23/android.jar \ #base-package</div><div class="line">-M AndroidManifest.xml                              #清单文件的路径</div></pre></td></tr></table></figure>
<p><strong>Step 2: 编译代码</strong></p>
<p>生成后的文件存放在gen目录下，有了R.java 我们就可以使用javac来编译我们的代码了，继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">javac -classpath \                          #添加依赖包，多个jar包用:分割</div><div class="line">$ANDROID_HOME/platforms/android-23/android.jar \ #sdk-23</div><div class="line">-source 1.7 -target 1.7 \                        #指明源码版本和字节码版本</div><div class="line">-d ./build \                                     #编译后的class文件的路径</div><div class="line">./java/com/haizhi/oa/buildtest/*.java \          #源码1，这是我们写的Activity</div><div class="line">./gen/com/haizhi/oa/buildtest/R.java             #源码2，R.java</div></pre></td></tr></table></figure>
<p><strong>Step 3: 编译为dex文件</strong></p>
<p>在上一步中，我们将代码编译成了字节码，但是dalvik并不能直接执行字节码，需要进一步的将class文件编译成dex文件，这个过程是通过<code>dx</code>这个工具实现的，在build目录下，我们继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dx --dex --output=classes.dex .   #指定输出为classes.dex 输入为当前目录</div></pre></td></tr></table></figure>
<p>至此，我们已经获得了生成一个Apk需要的所有东西。</p>
<p><strong>Step 4: 打包所有的资源文件</strong></p>
<p>在工程的根目录，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">aapt package \</div><div class="line">-f \</div><div class="line">-S res \</div><div class="line">-I $ANDROID_HOME/platforms/android-23/android.jar \</div><div class="line">-M AndroidManifest.xml \</div><div class="line">-F test.apk.u                       #生成apk文件</div></pre></td></tr></table></figure>
<p>此时，我们已经获得了一个apk文件，下面我们要对它签名，首先需要使用keytool工具生成一个签名文件，这个步骤可以自行百度。</p>
<p><strong>Step 5: 将classes.dex文件加入apk中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aapt add -f test.apk.u classes.dex</div></pre></td></tr></table></figure>
<p><strong>Step 6: 签名，对齐</strong><br>在工程的根目录，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">签名：</div><div class="line">jarsigner -storepass **密*码** -keystore ../chenlong.keystore test.apk.u chenlong</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">对齐：</div><div class="line">zipalign 4 test.apk.u test.apk</div></pre></td></tr></table></figure>
<p>经过上述5个步骤，我们生成了一个apk，下面安装到模拟器上执行一下，如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/74311666jw1f55mpfwxfrj20fa0cn3z3.jpg" alt=""></p>
<p>以上，就是一个最简单的Apk的编译过程，其中Apk最重要的两个部分，资源和代码被编译成了resources.arsc+res以及dex文件。res是实际的资源，resources.arsc则是一个索引，AssetManager通过这个索引获取资源的实际内容，这其中的过程比较复杂，暂时还没有太多的分析，至于dex文件，倒是可以啰嗦两句。</p>
<p>我们知道，java源码文件编译后生成了字节码文件，然后被jvm执行，字节码文件中有一个非常重要的区域是常量池，编译的过程中，字节码文件并不会保存方法和字段的最终内存布局信息，也就是说，方法和字段并不像C/C++那样被编译成地址，jvm在加载Class文件的时候，需要从常量池获取对应的符号引用，再在类创建时或运行时解析并翻译到具体的内存地址中【参考：深入理解Java虚拟机-JVM高级特性与最佳实践】。一个字节码文件中，除了方法体中的内容被编译为字节码指令外，大部分的信息都保存在常量池中，通过索引来访问，包括类的名称，类的字段，类的继承关系，类中方法的定义等。</p>
<p>那么，dex文件和class文件有什么区别呢？</p>
<p>首先，dalvik虚拟机的字节码指令是16位，而jvm是8位，因此，java 字节码被转换成dex 字节码；其次，dex文件将多个class文件合并成一个，合并了这些class文件的常量池，并作出了其他的优化，让dex文件执行的更快，更节省内存。对于dex文件的详细格式，可以参考 <a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="external">dex-format</a>，我尝试了一下直接阅读dex文件，讲真，不是很好读。。下图是我们刚刚编译出的dex文件的16进制格式，加了一些简单的标注和分块，一共3012个字节。</p>
<p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-6-24/85094739.jpg" alt=""></p>
<p>###0x02 进阶-编译一个带依赖的工程</p>
<p>在实际的编码过程中，我们往往会去依赖一些子工程，子工程有两种，一种是java工程，一种是Android Lib工程。java工程中不包含资源文件，编译后的输出是jar包，而Android Lib工程包含资源文件，编译后的输出为aar文件。</p>
<p>对于jar包，我们只需要在编译apk的java代码时，将jar包加入classpath，然后在编译dex文件时，将jar包一起编译进去就可以了，但是对于aar文件，就稍微有点复杂了。</p>
<p>首先，我们还是创建一个工程，如图：</p>
<p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-6-24/57725398.jpg" alt=""></p>
<p>这个工程依赖了design包，v7包中的appcompat，同时，上述这些包又依赖了v4包，，recyclerview，support-vector-drawable，animated-vector-drawable，support-annotations。</p>
<p>上述这些依赖都是Android Lib工程，因此我们需要处理依赖包中的资源。首先，我们需要这些依赖的aar文件作为输入，到哪里去找aar文件呢？最初，我在sdk下找到了这些依赖的jar包和相应的资源目录，但是，当我尝试编译的时候，总是提示我找不到资源，我很苦恼，后来在高旭大神的指点下，我看了一下gradle的实现方式，发现gradle并不使用jar包+资源来重新编译这些依赖库而是直接使用了google提供的这些依赖库的aar文件，于是我尝试将编译好的aar文件解包，再使用解包后的资源和jar包进行编译。</p>
<p><strong>Step 1: 生成R.java文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">aapt package -f -m --auto-add-overlay \</div><div class="line">-S res \</div><div class="line">-S /Users/chenlong/sdk/extras/android/m2repository/com/android/support/appcompat-v7/23.3.0/aarEx/res \</div><div class="line">-S /Users/chenlong/sdk/extras/android/m2repository/com/android/support/recyclerview-v7/23.3.0/aarEx/res \</div><div class="line">-S /Users/chenlong/sdk/extras/android/m2repository/com/android/support/design/23.3.0/aarEx/res \</div><div class="line">-J gen \</div><div class="line">--extra-packages android.support.v7.appcompat:android.support.v7.recyclerview:android.support.design \</div><div class="line">-I $ANDROID_HOME/platforms/android-23/android.jar -M ./AndroidManifest.xml</div></pre></td></tr></table></figure>
<p>其中，<code>--auto-add-overlay</code> 参数用来加载多个资源目录，按照从左向右的顺序，如果后面的资源重复则跳过，如果不重复则新增。<br><code>--extra-packages</code>用来对不同的资源目录生成包名不同的R文件，多个包名通过<code>:</code>分割。</p>
<p><strong>Step 2: 编译代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">javac -classpath $ANDROID_HOME/extras/android/support/v7/appcompat/libs/android-support-v4.jar:\</div><div class="line">$ANDORID_HOME/extras/android/support/annotations/android-support-annotations.jar:\</div><div class="line">$ANDROID_HOME/platforms/android-23/android.jar:\</div><div class="line">$ANDROID_HOME/extras/android/support/design/libs/android-support-design.jar:\</div><div class="line">$ANDROID_HOME/extras/android/support/v7/appcompat/libs/android-support-v7-appcompat.jar:\</div><div class="line">$ANDROID_HOME/extras/android/support/v7/recyclerview/libs/android-support-v7-recyclerview.jar \</div><div class="line">-source 1.7 -target 1.7 \</div><div class="line">-d ./build \</div><div class="line">./java/com/haizhi/oa/buildtest/*.java \</div><div class="line">./gen/com/haizhi/oa/buildtest/R.java \</div><div class="line">./gen/android/support/design/R.java \</div><div class="line">./gen/android/support/v7/appcompat/R.java \</div><div class="line">./gen/android/support/v7/recyclerview/R.java</div></pre></td></tr></table></figure>
<p><strong>Step 3: 编译dex文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dx --dex --output=classes.dex . \</div><div class="line">/Users/chenlong/sdk/extras/android/m2repository/com/android/support/support-v4/23.3.0/aarEx/classes.jar \</div><div class="line">/Users/chenlong/sdk/extras/android/m2repository/com/android/support/support-v4/23.3.0/aarEx/libs/internal_impl-23.3.0.jar \</div><div class="line">/Users/chenlong/sdk/extras/android/m2repository/com/android/support/design/23.3.0/aarEx/classes.jar \</div><div class="line">/Users/chenlong/sdk/extras/android/m2repository/com/android/support/appcompat-v7/23.3.0/aarEx/classes.jar \</div><div class="line">/Users/chenlong/sdk/extras/android/m2repository/com/android/support/recyclerview-v7/23.3.0/aarEx/classes.jar \</div><div class="line">/Users/chenlong/sdk/extras/android/m2repository/com/android/support/support-vector-drawable/23.3.0/aarEx/classes.jar \</div><div class="line">/Users/chenlong/sdk/extras/android/m2repository/com/android/support/animated-vector-drawable/23.3.0/aarEx/classes.jar \</div><div class="line">/Users/chenlong/sdk/extras/android/m2repository/com/android/support/support-annotations/23.3.0/support-annotations-23.3.0.jar</div></pre></td></tr></table></figure>
<p><strong>Step 4: 生成apk文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">aapt package -f -m --auto-add-overlay \</div><div class="line">-S res \</div><div class="line">-S /Users/chenlong/sdk/extras/android/m2repository/com/android/support/appcompat-v7/23.3.0/aarEx/res \</div><div class="line">-S /Users/chenlong/sdk/extras/android/m2repository/com/android/support/recyclerview-v7/23.3.0/aarEx/res \</div><div class="line">-S /Users/chenlong/sdk/extras/android/m2repository/com/android/support/design/23.3.0/aarEx/res \</div><div class="line">-I $ANDROID_HOME/platforms/android-23/android.jar -M ./AndroidManifest.xml \</div><div class="line">-F test.apk.u</div></pre></td></tr></table></figure>
<p><strong>Step 5: 将classes.dex文件加入apk中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aapt add -f test.apk.u classes.dex</div></pre></td></tr></table></figure>
<p>后面的签名、对齐操作和之前一样</p>
<p>最后，我们在模拟器上运行一下打包后的apk文件，如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/74311666jw1f55phg8m51j20g00ic75h.jpg" alt=""></p>
<p>###0x03 总结</p>
<p>编译流程的简单分析就是这些，在上述流程中我们可以看到，主要过程是资源处理和dex文件生成上，其中对资源的处理是插件化的一个难点，我的分析并不是很全面，比如对于多个资源目录合并的过程，aapt自身提供的机制和gradle的实现就不太一样，gradle在最终调用aapt之前已经将资源合并，传入aapt的只有一个合并后的资源目录，可以参考<a href="http://tools.android.com/tech-docs/new-build-system/resource-merging" target="_blank" rel="external">gradle 资源合并机制</a>，后续我会针对资源文件的处理做单独的分析。</p>
<p>上述内容如有错误，恳请指正，我会继续分析插件化的相关技术实现，敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插件化-Apk编译过程概述&quot;&gt;&lt;a href=&quot;#插件化-Apk编译过程概述&quot; class=&quot;headerlink&quot; title=&quot;插件化-Apk编译过程概述&quot;&gt;&lt;/a&gt;插件化-Apk编译过程概述&lt;/h2&gt;&lt;p&gt;###0x00&lt;/p&gt;
&lt;p&gt;大致的看了一下目前插件
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gradle学习笔记（公司技术分享）</title>
    <link href="http://yoursite.com/2016/07/23/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/07/23/Gradle学习笔记/</id>
    <published>2016-07-23T07:19:22.000Z</published>
    <updated>2016-08-22T02:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gradle-学习笔记"><a href="#Gradle-学习笔记" class="headerlink" title="Gradle 学习笔记"></a>Gradle 学习笔记</h2><blockquote>
<p>以下内容，理论部分大部分是gradle和groovy的官方文档的解释，实例部分是自己的尝试，如有错误，请不吝指正，谢谢！</p>
</blockquote>
<h3 id="0x00-groovy-基本知识"><a href="#0x00-groovy-基本知识" class="headerlink" title="0x00 groovy 基本知识"></a>0x00 groovy 基本知识</h3><h4 id="groovy与java"><a href="#groovy与java" class="headerlink" title="groovy与java"></a>groovy与java</h4><p>groovy 是一个jvm语言，这意味着除了groovy编译器提供的语法糖和groovy标准库以外，它和java没有区别，我们来看一个Hello World</p>
<p>g2j.groovy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def author = &apos;chenlong&apos;</div><div class="line">def getAuthorName()&#123;</div><div class="line">    //return author  思考一下为什么这里不能访问到author变量</div><div class="line">    return &apos;chenlong&apos;</div><div class="line">&#125;</div><div class="line">def sayHello()&#123;</div><div class="line">    println &apos;Hello &apos;+getAuthorName()</div><div class="line">&#125;</div><div class="line">sayHello()</div></pre></td></tr></table></figure>
<p>看一下编译成jvm字节码后的结果</p>
<p>g2j.class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">import groovy.lang.Binding;</div><div class="line">import groovy.lang.Script;</div><div class="line">import org.codehaus.groovy.runtime.BytecodeInterface8;</div><div class="line">import org.codehaus.groovy.runtime.InvokerHelper;</div><div class="line">import org.codehaus.groovy.runtime.callsite.CallSite;</div><div class="line"></div><div class="line">public class g2j extends Script</div><div class="line">&#123;</div><div class="line">  public g2j()</div><div class="line">  &#123;</div><div class="line">    g2j this;</div><div class="line">    CallSite[] arrayOfCallSite = $getCallSiteArray();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public g2j(Binding context)</div><div class="line">  &#123;</div><div class="line">    super(context);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static void main(String[] args)</div><div class="line">  &#123;</div><div class="line">    CallSite[] arrayOfCallSite = $getCallSiteArray();</div><div class="line">    arrayOfCallSite[0].call(InvokerHelper.class, g2j.class, args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public Object run()</div><div class="line">  &#123;</div><div class="line">    CallSite[] arrayOfCallSite = $getCallSiteArray(); </div><div class="line">    Object author = &quot;chenlong&quot;;//注意这里，author并不是d2j类的成员变量，所以无法在方法内部访问</div><div class="line">    if ((__$stMC) || (BytecodeInterface8.disabledStandardMetaClass()))     </div><div class="line">        return arrayOfCallSite[1].callCurrent(this); </div><div class="line">    else </div><div class="line">        return sayHello(); </div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public Object getAuthorName()</div><div class="line">  &#123;</div><div class="line">    CallSite[] arrayOfCallSite = $getCallSiteArray(); </div><div class="line">    return &quot;chenlong&quot;; </div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public Object sayHello() &#123;</div><div class="line">    CallSite[] arrayOfCallSite = $getCallSiteArray(); </div><div class="line">    if ((__$stMC) || (BytecodeInterface8.disabledStandardMetaClass())) </div><div class="line">        return arrayOfCallSite[2].callCurrent(</div><div class="line">                                this, </div><div class="line">                                arrayOfCallSite[3].call(&quot;Hello &quot;, arrayOfCallSite[4].callCurrent(this))); </div><div class="line">    else </div><div class="line">        return arrayOfCallSite[5].callCurrent(</div><div class="line">                                this,                                 </div><div class="line">                                arrayOfCallSite[6].call(&quot;Hello &quot;, getAuthorName()));</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的概念也许我们稍微陌生一点，但是实际上，我们可以简单把它当做一个匿名类，只是编译器提供了更加简单的语法来实现它的功能。</p>
<p>groovy的闭包是一种表示可执行代码块的方法，闭包也是对象，可以像方法一样传递参数，并且可以在需要的地方执行。一个最简单的闭包形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def clos = &#123; params -&gt;</div><div class="line">    println &quot;Hello $&#123;params&#125;&quot;</div><div class="line">&#125;</div><div class="line">clos(&quot;World&quot;)</div></pre></td></tr></table></figure>
<p>同时，闭包可以作为参数传递，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def clos = &#123; it -&gt;</div><div class="line">    return it%2 == 0</div><div class="line">&#125;</div><div class="line">def list = [1,2,3,4,5,6]</div><div class="line">def filter(list,closure)&#123;</div><div class="line">    def res = []</div><div class="line">    for(i in list)&#123;</div><div class="line">        if(clos(i))</div><div class="line">            res.add()</div><div class="line">    &#125;</div><div class="line">    return res</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>闭包有三个很重要的属性分别是：<code>this</code>,<code>owner</code>,<code>delegate</code>，分别代表以下概念：</p>
<p>this: 表示定义该闭包的类的实例对象（实例闭包）或者类本身（静态闭包）</p>
<p>owner: 它的含义基本上跟this的含义一样，只是除了一种情况，如果该闭包是在其他的闭包中定义的，那么owner是指向定义它的闭包对象</p>
<p>delegate: 它的含义大多数情况下是跟owner的含义一样，除非它被显示的修改（通过Closure.setDelegate()方法进行修改）</p>
<h4 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h4><p>借助闭包的特性，我们可以尝试写一个简单的DSL。下面的代码展示了如何借助groovy的语法特性来实现一个DSL，这些特性我们稍后会在gradle的脚本中看到。</p>
<p>BookDSL.groovy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Book &#123;</div><div class="line">    def _name = &apos;&apos;</div><div class="line">    def _price = 0.0</div><div class="line">    def shop = []</div><div class="line">    def static config(config)&#123;</div><div class="line">        Book book = new Book(shop:[&apos;A&apos;,&apos;B&apos;])</div><div class="line">        config.delegate = book</div><div class="line">        config()</div><div class="line">    &#125;</div><div class="line">    def name(name)&#123;</div><div class="line">        this._name = name</div><div class="line">    &#125;</div><div class="line">    def price(price)&#123;</div><div class="line">        this._price = price</div><div class="line">    &#125;</div><div class="line">    def getDetail()&#123;</div><div class="line">        println &quot;name : $&#123;_name&#125;&quot;</div><div class="line">        println &quot;price : $&#123;_price&#125;&quot;</div><div class="line">        println &quot;shop : $&#123;shop&#125;&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Book.config &#123;</div><div class="line">    name &apos;test&apos;</div><div class="line">    price  1.2</div><div class="line">    detail</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="0x01-Gradle-基本概念"><a href="#0x01-Gradle-基本概念" class="headerlink" title="0x01 Gradle 基本概念"></a>0x01 Gradle 基本概念</h3><h4 id="1-基本元素"><a href="#1-基本元素" class="headerlink" title="1. 基本元素"></a>1. 基本元素</h4><p><strong>Project</strong> : 需要完成的工作，这里的工作不一定是构建，可以是任何一件事情，当然我们也可以简单的理解它就是我们需要构建的工程。</p>
<p><strong>Script</strong> : gradle的脚本文件，通过脚本，我们可以定义一个Project</p>
<p><strong>Task</strong> : Project中的具体执行的原子性工作，以构建一个工程为例，它可以是 <em>编译</em>,<em>执行单元测试</em>,<em>发布</em> 等。</p>
<h4 id="2-Script元素"><a href="#2-Script元素" class="headerlink" title="2. Script元素"></a>2. Script元素</h4><p><strong>Init Script</strong></p>
<p>似乎从来没有使用过，但是在每一次构建开始之前，都会执行init script，用来设置一些全局变量，有多个位置可以存放init script如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">USER_HOME/.gradle/ </div><div class="line">USER_HOME/.gradle/init.d/</div><div class="line">GRADLE_HOME/init.d/</div></pre></td></tr></table></figure>
<p><strong>Settings Script</strong></p>
<p>用来在组织多工程的构建，存在于root工程下，settings.gradle</p>
<p>上述script在运行时都会被编译成一个实现了Script接口的class，同时每一个script都有一个委托对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Build Script -&gt; Project</div><div class="line"></div><div class="line">Init Script  -&gt; Gradle</div><div class="line"></div><div class="line">Settings Script -&gt; Settings</div></pre></td></tr></table></figure></p>
<p>任何没有在脚本中定义的方法或者属性，都会被委托给这个脚本的委托对象执行。</p>
<p><strong>Build Script</strong></p>
<p>每一个build.gradle都是一个Build Scrpit,它由两种元素组成。</p>
<p><em>statement</em></p>
<p>可以包含方法调用，属性赋值，局部变量定义等</p>
<p><em>script blocks</em></p>
<p>block的概念稍微复杂一点，首先我们先要理解一个groovy的元素，闭包。可以参考上面对<strong>闭包</strong>的解释</p>
<p>有了闭包的概念，那么理解script block就没有障碍了，我们直接看文档中的定义：</p>
<blockquote>
<p>A script block is a method call which takes a closure as a parameter. The closure is treated as a configuration closure which configures some delegate object as it executes. </p>
</blockquote>
<p>翻译一下就是</p>
<blockquote>
<p>一个脚本块是一个接受一个闭包作为参数的方法，这个闭包在执行的时候配置它的委托对象。</p>
</blockquote>
<p>文档描述的比较抽象，我们看一个例子：</p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def buildVersion = &apos;1.2.0&apos;</div><div class="line">def author = &apos;chenlong&apos;</div><div class="line">allprojects &#123;</div><div class="line">    println &apos;this project is created by $&#123;author&#125;&apos;</div><div class="line">    setVersion(buildVersion)</div><div class="line">&#125;</div><div class="line">getAllprojects().each&#123;</div><div class="line">    println it.getVersion()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们定义了两个变量分别是<code>buildVersion</code>和<code>author</code>,在执行时，这个两个变量会成为Script Class的属性。然后，我们使用了一个script block，根据定义，这个block对应着一个同名方法<code>allprojects</code>，可是我们并没有在脚本中定义这样一个方法，那它如何执行呢？回想一下我们刚刚看到的build script的委托对象，没错，这个方法被委托给了Project对象执行，查看文档，我们确实在Project中找到了这个同名方法.</p>
<p>接下来，我们在块中写了两行代码,这就是这个闭包需要执行的代码，首先打印一行文字，其次setVersion()。同样的，我们没有定义setVersion这个方法，这就涉及到闭包的一些概念，我们换一种写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delegate.setVersion(buildVersion)</div></pre></td></tr></table></figure>
<p>setVersion 这个方法实际上是由闭包的委托对象执行的，那委托对象是什么呢？我们查阅一下allprojects这个方法的Api，如下</p>
<p><img src="http://i4.piimg.com/567571/8fc903bd2332edb1.png" alt=""></p>
<p>这个闭包的委托对象是当前的project和它的子project,也就是对于一个包含子工程的工程，这个闭包会执行多次,是不是这样呢，我们实验一下，我创建了一个结构如下的工程</p>
<p><img src="http://i4.piimg.com/567571/702f33541e214027.png" alt=""></p>
<p>在root工程下执行上述脚本，结果如下:</p>
<p><img src="http://i4.piimg.com/567571/74c39fb6f563fb56.png" alt=""></p>
<h4 id="3-Project-对象"><a href="#3-Project-对象" class="headerlink" title="3. Project 对象"></a>3. Project 对象</h4><p>每一个build.gradle文件和一个Project对象一一对应，在执行构建的时候，gradle通过以下方式为每一个工程创建一个Project对象：</p>
<ol>
<li>创建一个Settings对象，</li>
<li>根据settings.gradle文件配置它</li>
<li>根据Settings对象中定义的工程的父子关系创建Project对象</li>
<li>执行每一个工程的build.gradle文件配置上一步中创建的Project对</li>
</ol>
<p>在build.gradle文件中定义的属性和方法会委托给Project对象执行，每一个project对象在寻找一个属性的时候有5个作用域作为范围，分别是：</p>
<p><strong>属性可见范围</strong></p>
<ol>
<li>Project 本身</li>
<li>Project的<em>extra</em>属性</li>
<li>通过<em>plugin</em>添加的<em>extension</em>，每一个extension通过一个和extension同名的只读属性访问</li>
<li>通过<em>plugin</em>添加的属性。一个<em>plugin</em>可以通过Project的Convention对象为project添加属性和方法。</li>
<li>project中的task,一个task对象可以通过project中的同名属性访问，但是它是只读的</li>
<li>当前project的父工程的<em>extra</em>属性和<em>convention</em>属性</li>
</ol>
<p><strong>方法可见范围</strong></p>
<ol>
<li>Project对象本身</li>
<li>build.gradle文件中定义的方法</li>
<li>通过<em>plugin</em>添加的extension，每一个extension都作为一个接受一个闭包/Action作为参数的方法被访问</li>
<li>通过<em>plugin</em>添加的方法。一个<em>plugin</em>可以通过Project的Convention对象为project添加属性和方法。</li>
<li>project中的<em>task</em>,每一个task 都会在当前project中存在一个接受一个闭包或者/Action作为参数的方法，这个闭包会在task的configure(closure)方法中调用。</li>
<li>当前工程的父工程中的方法</li>
<li>当前工程的属性可见范围中所有的闭包属性都可以作为方法访问</li>
</ol>
<h4 id="4-构建的生命周期"><a href="#4-构建的生命周期" class="headerlink" title="4. 构建的生命周期"></a>4. 构建的生命周期</h4><p>一次gradle的构建有三个过程</p>
<p><em>初始化</em></p>
<p>gradle支持单工程和多工程构建，在初始化的过程中，gradle决定了这次构建包含哪些工程，并且为每一个工程创建一个Project对象。需要注意一点，对于一个多工程的项目，即使通过传入的参数指定了需要构建的子工程，但是，所有在Settings script中包含的工程的build script仍然会执行，因为gradle需要为每一个Project对象配置完整的信息。</p>
<p><em>配置</em></p>
<p>在配置的过程中，本次构建包含的所有工程的build script 都会执行一次，同时每个工程的Project对象都会被配置，运行时需要的信息在这个过程中被配置到Projec对象中。最重要的是，在build script中定义的task将在这个过程创建，并被初始化。需要注意的是，在一般情况下，只要在初始化阶段创建的Project对象都会被配置，即使这个工程没有参与本次构建。但是，在1.4之后，一个新的特性被引入，<em>Configuration on demand</em> 如果开启这个选项，那么即使在setting.gradle中包含了工程，但是这个工程不参与本次构建，那么它的Project对象会被创建，但是不会被配置。这也就解释了为什么gradle在多工程构建时运行缓慢了，因为默认情况下，每一个工程的build script都会执行。</p>
<p><em>执行</em></p>
<p>gradle通过传入的参数来决定哪些任务会被执行，并生成任务的依赖图(DAG)，这意味着，即使在build Script中定义了一个task，但是在构建时这个任务并不会执行，那么这个task对象虽然会被创建，但是不会在任务依赖图中出现。</p>
<p>下面我们通过一个例子来看看gradle的构建生命周期究竟是怎么样的。</p>
<p>工程结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root Project:gradleStudy</div><div class="line">    -- lib</div><div class="line">        build.gradle</div><div class="line">    -- sub</div><div class="line">        build.gradle</div><div class="line">    build.gradle</div><div class="line">    settings.gradle</div></pre></td></tr></table></figure>
<p>root/settings.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">println &quot;setting srcipt execute &quot;</div><div class="line">rootProject.name = &apos;gradleStudy&apos;</div><div class="line">include &apos;:lib&apos;</div><div class="line">include &apos;:sub&apos;</div></pre></td></tr></table></figure></p>
<p>root/build.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">println &quot;root build srcipt execute&quot;</div><div class="line">allprojects &#123;</div><div class="line">    afterEvaluate &#123; project -&gt;</div><div class="line">        println &quot;define in root project : after $&#123;project.name&#125; evaluate&quot;</div><div class="line">    &#125;</div><div class="line">    beforeEvaluate &#123; project -&gt;</div><div class="line">        println &quot;define in root project : before $&#123;project.name&#125; evaluate&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.settingsEvaluated &#123; settings -&gt;</div><div class="line">    println &quot;emit by gradle : Setting evaluated&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.projectsLoaded &#123; gradle -&gt;</div><div class="line">    println &quot;emit by gradle : project loaded&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.beforeProject &#123; project -&gt;</div><div class="line">    println &quot;emit by gradle : before $&#123;project.name&#125; evaluate &quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.afterProject &#123; project -&gt;</div><div class="line">    println &quot;emit by gradle : after $&#123;project.name&#125; evaluate &quot;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.projectsEvaluated &#123; gradle -&gt;</div><div class="line">    println &quot;emit by gradle : all project evaluated &quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.taskGraph.whenReady &#123; graph -&gt;</div><div class="line">    println &quot;task graph is ready&quot;</div><div class="line">    graph.getAllTasks().each &#123;</div><div class="line">        println &quot;task $&#123;it.name&#125; will execute&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.taskGraph.beforeTask &#123; task -&gt;</div><div class="line">   println &quot;before $&#123;task.name&#125; execute&quot; </div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.taskGraph.afterTask &#123; task -&gt;</div><div class="line">    println &quot;after $&#123;task.name&#125; execute&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.buildFinished &#123; buildResult -&gt;</div><div class="line">    println &quot;emit by gradle : build finished&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">println &quot;all project size : $&#123;allprojects.size()&#125;&quot;</div></pre></td></tr></table></figure></p>
<p>lib/build.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">println &apos;lib build script execute&apos;</div><div class="line">task libTask0 &lt;&lt;&#123;</div><div class="line">    println &quot;$&#123;name&#125; execute&quot;</div><div class="line">&#125;</div><div class="line">task libTask1 &lt;&lt; &#123;</div><div class="line">   println &quot;$&#123;name&#125; execute&quot; </div><div class="line">&#125;</div><div class="line">task libTask2(dependsOn:&apos;libTask1&apos;)&lt;&lt;&#123;</div><div class="line">   println &quot;$&#123;name&#125; execute&quot; </div><div class="line">&#125;</div><div class="line"></div><div class="line">beforeEvaluate &#123; project -&gt;</div><div class="line">    println &quot;define in lib : before $&#123;project.name&#125; evaluate&quot;</div><div class="line">&#125;</div><div class="line">afterEvaluate &#123; project -&gt;</div><div class="line">    println &quot;define in lib : after $&#123;project.name&#125; evaluate&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">println &quot;lib project has $&#123;tasks.size()&#125; tasks&quot;</div></pre></td></tr></table></figure></p>
<p>sub/build.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">println &apos;sub build script execute&apos;</div><div class="line">task subTask1 &lt;&lt; &#123;</div><div class="line">   println &quot;$&#123;name&#125; execute&quot; </div><div class="line">&#125;</div><div class="line">task subTask2(dependsOn:&apos;libTask1&apos;)&lt;&lt;&#123;</div><div class="line">   println &quot;$&#123;name&#125; execute&quot; </div><div class="line">&#125;</div><div class="line">beforeEvaluate &#123; project -&gt;</div><div class="line">    println &quot;define in sub : $&#123;project.name&#125; evaluate&quot;</div><div class="line">&#125;</div><div class="line">afterEvaluate &#123; project -&gt;</div><div class="line">    println &quot;define in sub : $&#123;project.name&#125; evaluate&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在根目录下执行 <code>gradle -q :lib:libTask2 --configure-on-demand</code></p>
<p><img src="http://i1.piimg.com/567571/cbde5ab22c332e0a.png" alt=""></p>
<p>在根目录下执行 <code>gradle -q :lib:libTask2</code></p>
<p><img src="http://i1.piimg.com/567571/ff64eaf370e198df.png" alt=""></p>
<p>从上述例子中我们验证了以下结果：</p>
<ol>
<li>在configuration demand 模式下执行构建时，虽然sub 工程的Project对象会创建，但是sub/build.gradle并不会执行，并且sub工程的Project不会被配置</li>
<li>如果一个task在build.gradle中定义，但是在构建中不会执行，那么它的Task对象会创建，但是不会在任务图中出现。</li>
<li>我们可以通过Gradle或者Project对象中定义的方法获取生命周期中每一个过程在执行中的回调。这里注意一下，我们定义的一些回调在实际执行中似乎并没有被触发，例如，<code>settingsEvaluated</code>,<code>projectsLoaded</code>。这个问题，似乎和gradle的版本更新有关，我正在尝试获取官方的解释。</li>
</ol>
<h3 id="0x02-写一个简单的插件"><a href="#0x02-写一个简单的插件" class="headerlink" title="0x02 写一个简单的插件"></a>0x02 写一个简单的插件</h3><p>我跳过了一些比较简单的内容，例如如何在Build Script中定义一个Task，有兴趣的可以参考文档。</p>
<p>首先看一下工程结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gradleStudy                      //root工程</div><div class="line">    lib                          //子工程</div><div class="line">    repo                         //本地maven目录</div><div class="line">    simplePlugin                 //plugin工程</div><div class="line">    build.gradle                 //root工程的build script</div><div class="line">    settings.gradle              //root工程的setting script</div></pre></td></tr></table></figure>
<p>simplePlugin工程的目录结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">simplePlugin</div><div class="line">    src</div><div class="line">        main</div><div class="line">            groovy</div><div class="line">                com</div><div class="line">                    haizhi</div><div class="line">                        oa</div><div class="line">                            GreetingExtension.groovy     //Extension Model</div><div class="line">                            GreetingPlugin.groovy        //插件类</div><div class="line">                            SayHelloTask.groovy          //任务类</div><div class="line">            resources</div><div class="line">                META-INF</div><div class="line">                    gralde-plugins</div><div class="line">                        greeting-plugin.properties       //插件名</div><div class="line">    build.gradle</div></pre></td></tr></table></figure>
<p>首先，插件工程可以用任意的jvm语言编写，例如，scala，groovy，java等，最终每一个插件都会打包成一个jar包，其中META-INF文件下中每一个.properties文件代表一个Plugin，里面指明了插件类的全类名，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation-class=com.haizhi.oa.GreetingPlugin</div></pre></td></tr></table></figure>
<p>GreetingExtension.groovy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package com.haizhi.oa</div><div class="line"></div><div class="line">//定义一个属性类，其中包含message和showAuthorName</div><div class="line">class GreetingExtension &#123;</div><div class="line">    def message = &apos;&apos;</div><div class="line">    def showAuthorName = false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>GreetingPlugin.groovy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.haizhi.oa</div><div class="line">import org.gradle.api.Project</div><div class="line">import org.gradle.api.Plugin</div><div class="line"></div><div class="line">class GreetingPlugin implements Plugin&lt;Project&gt;&#123;</div><div class="line">    @Override</div><div class="line">    public void apply(Project project)&#123;</div><div class="line">        //创建一个类型为GreetingExtension,名称为greeting的属性</div><div class="line">        project.extensions.create(&apos;greeting&apos;,GreetingExtension) </div><div class="line">        //创建一个类型为SayHelloTask，名称为sayHello的任务</div><div class="line">        project.task(&apos;sayHello&apos;,type:SayHelloTask)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SayHellTask.groovy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package com.haizhi.oa</div><div class="line">import org.gradle.api.DefaultTask</div><div class="line">import org.gradle.api.tasks.TaskAction</div><div class="line"></div><div class="line">class SayHelloTask extends DefaultTask&#123;</div><div class="line">    //定义一个属性</div><div class="line">    def author = &apos;&apos;</div><div class="line">    @TaskAction</div><div class="line">    public void sayHello()  &#123;</div><div class="line">        //从Project中获取greeting属性</div><div class="line">        if(project.greeting.showAuthorName)&#123;</div><div class="line">            println &quot;Hello $&#123;author&#125; $&#123;project.greeting.message&#125;&quot;   </div><div class="line">        &#125;else&#123;</div><div class="line">            println &quot;Hello $&#123;project.greeting.message&#125;&quot; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>build.gradle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;groovy&apos;</div><div class="line">apply plugin: &apos;maven&apos;</div><div class="line"></div><div class="line">//定义发布到maven的版本,group,name</div><div class="line">version = &apos;1.0.0&apos;</div><div class="line">group = &apos;com.haizhi.oa&apos;</div><div class="line">archivesBaseName=&apos;greeting-plugin&apos;</div><div class="line"></div><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile &apos;org.codehaus.groovy:groovy-all:2.4.4&apos;</div><div class="line">    compile gradleApi()</div><div class="line">    compile localGroovy()</div><div class="line">&#125;</div><div class="line">uploadArchives&#123;</div><div class="line">    repositories.mavenDeployer&#123;</div><div class="line">        repository(url : &apos;file:../repo&apos;)//定义本地maven地址</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在simplePlugin的根目录下执行，<code>gralde uploadArchives</code>，编译插件工程，并发布到<code>../repo</code>目录。</p>
<p>以上，我们就创建好了一个gradle plugin，那么如何使用它呢？</p>
<p>首先，在root工程下，我们通过<code>buildscript</code>引入插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">buildscript&#123;</div><div class="line">    repositories&#123;</div><div class="line">        mavenCentral()</div><div class="line">        maven &#123;</div><div class="line">            url uri(&apos;./repo&apos;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.haizhi.oa:greeting-plugin:1.0.0&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，在lib工程下，我们应用这个插件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apply plugin : &apos;greeting-plugin&apos;</div><div class="line">greeting.message = &apos;this is a simple plugin&apos; //为greeting属性赋值</div><div class="line">greeting.showAuthorName = true               //为greeting属性赋值</div><div class="line">sayHello.author = &apos;chenlong&apos;                 //为sayHello任务的author属性赋值</div></pre></td></tr></table></figure>
<p>似乎和我们通常看到的插件配置方式不太一样，我们换一种配置方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">apply plugin : &apos;greeting-plugin&apos;</div><div class="line">greeting &#123;</div><div class="line">    message &apos;this is a simple plugin&apos;   </div><div class="line">    showAuthorName true</div><div class="line">&#125;</div><div class="line">sayHello &#123;</div><div class="line">    author &apos;chenlong&apos;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上去是不是熟悉了很多</p>
<p>下面，在lib或者根目录下执行，<code>gradle sayHello</code>，执行结果如下：</p>
<p><img src="http://i2.piimg.com/567571/e976e2c97a4237ab.png" alt=""></p>
<p>以上就是一个自定义插件的创建和应用过程，虽然很简单，但是可以帮助我们理解gradle是如何通过plugin完成很多复杂的工作的。</p>
<h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>gradle在定义一个构建工作的时候，主要是围绕着它的两个核心类，Project和Task,在这两个类的基础上，gradle定义了它的规则，例如它的生命周期，例如task的依赖图。在保证了这些核心功能后，所有外围的功能都是通过Plugin来进行的，这一点非常值得我们学习。同时，task的依赖图这个功能也是gradle的一个很强大的功能，它让我们有机会在任务执行之前就能对本次构建有一个全局的理解，同时也提供了接口让我们hook到task的执行过程中，完成一些非常酷炫的功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Gradle-学习笔记&quot;&gt;&lt;a href=&quot;#Gradle-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Gradle 学习笔记&quot;&gt;&lt;/a&gt;Gradle 学习笔记&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以下内容，理论部分大部分是gradle和g
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Monkey压力自动化测试</title>
    <link href="http://yoursite.com/2016/07/23/Monkey%E5%8E%8B%E5%8A%9B%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2016/07/23/Monkey压力自动化测试/</id>
    <published>2016-07-23T06:58:52.000Z</published>
    <updated>2016-07-26T07:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Monkey压力自动化测试"><a href="#Monkey压力自动化测试" class="headerlink" title="Monkey压力自动化测试"></a>Monkey压力自动化测试</h2><h3 id="一、Monkey测试简介"><a href="#一、Monkey测试简介" class="headerlink" title="一、Monkey测试简介"></a>一、Monkey测试简介</h3><hr>
<p>Monkey测试是Android平台自动化测试的一种手段，通过Monkey程序模拟用户触摸屏幕、滑动Trackball、按键等操作来对设备上的程序进行压力测试，检测程序多久的时间会发生异常。</p>
<a id="more"></a>
<h3 id="二、Monkey程序介绍"><a href="#二、Monkey程序介绍" class="headerlink" title="二、Monkey程序介绍"></a>二、Monkey程序介绍</h3><hr>
<ul>
<li>Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是：/system/framework/monkey.jar；</li>
<li>Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中的存放路径是：/system/bin/monkey；</li>
</ul>
<h3 id="三、Monkey命令的简单帮助"><a href="#三、Monkey命令的简单帮助" class="headerlink" title="三、Monkey命令的简单帮助"></a>三、Monkey命令的简单帮助</h3><hr>
<p>要获取Monkey命令自带的简单帮助，在CMD中执行命令：</p>
<p>adb shell monkey –help</p>
<h3 id="四、Monkey命令参数介绍"><a href="#四、Monkey命令参数介绍" class="headerlink" title="四、Monkey命令参数介绍"></a>四、Monkey命令参数介绍</h3><hr>
<p>1) 参数:-p</p>
<p>参数-p用于约束限制，用此参数指定一个或多个包（Package，即App）。指定</p>
<p>包之后，Monkey将只允许系统启动指定的APP。如果不指定包，Monkey将允许系统启动设备中的所有APP。</p>
<ul>
<li>指定一个包： adb shell monkey -p com.htc.Weather 100</li>
</ul>
<p>说明：com.htc.Weather为包名，100是事件计数（即让Monkey程序模拟100次随机用户事件）。</p>
<ul>
<li><p>指定多个包：adb shell monkey -p com.htc.Weather –p com.htc.pdfreader  -p com.htc.photo.widgets 100</p>
</li>
<li><p>不指定包：adb shell monkey 100</p>
</li>
</ul>
<p>　说明：Monkey随机启动APP并发送100个随机事件。</p>
<ul>
<li><p>要查看设备中所有的包，在CMD窗口中执行以下命令：</p>
<blockquote>
<p>adb shell</p>
</blockquote>
<p>#cddata/data</p>
<p>#ls</p>
</li>
</ul>
<p>2) 参数:  -v</p>
<p>用于指定反馈信息级别（信息级别就是日志的详细程度），总共分3个级别，分别对应的参数如下表所示：</p>
<p>日志级别 Level0</p>
<p>示例 adb shellmonkey -p com.htc.Weather –v 100</p>
<p>说明 缺省值，仅提供启动提示、测试完成和最终结果等少量信息</p>
<p>日志级别 Level 1</p>
<p>示例 adb shellmonkey -p com.htc.Weather –v -v 100</p>
<p>说明  提供较为详细的日志，包括每个发送到Activity的事件信息</p>
<p>日志级别 Level 2</p>
<p>示例 adb shellmonkey -p com.htc.Weather –v -v –v 100</p>
<p>说明  最详细的日志，包括了测试中选中/未选中的Activity信息</p>
<p>3) 参数：  -s</p>
<p>用于指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。</p>
<ul>
<li>示例：</li>
</ul>
<p>　Monkey测试1：adb shell monkey -p com.htc.Weather –s 10 100</p>
<p>  Monkey 测试2：adb shell monkey -p com.htc.Weather–s 10 100</p>
<p>   两次测试的效果是相同的，因为模拟的用户操作序列（每次操作按照一定的先后顺序所组成的一系列操作，即一个序列）是一样的。操作序</p>
<p>列虽   然是随机生成的，但是只要我们指定了相同的Seed值，就可以保证两次测试产生的随机操作序列是完全相同的，所以这个操作序列伪随</p>
<p>机的；</p>
<p>4) 参数：  –throttle &lt;毫秒&gt;</p>
<p>用于指定用户操作（即事件）间的时延，单位是毫秒；</p>
<ul>
<li>示例：adb shell monkey -p com.htc.Weather –throttle 3000 100</li>
</ul>
<p>5) 参数：  –ignore-crashes</p>
<p>用于指定当应用程序崩溃时（Force&amp; Close错误），Monkey是否停止运行。如果使用此参数，即使应用程序崩溃，Monkey依然会发送事件，直</p>
<p>到事件计数完成。</p>
<ul>
<li><p>示例1：adb shellmonkey -p com.htc.Weather –ignore-crashes 1000</p>
<p>测试过程中即使Weather程序崩溃，Monkey依然会继续发送事件直到事件数目达到1000为止；</p>
</li>
<li><p>示例2：adb shellmonkey -p com.htc.Weather 1000</p>
<p>测试过程中，如果Weather程序崩溃，Monkey将会停止运行。</p>
</li>
</ul>
<p>6) 参数：  –ignore-timeouts</p>
<p>用于指定当应用程序发生ANR（Application No Responding）错误时，Monkey是否停止运行。如果使用此参数，即使应用程序发生ANR错误，</p>
<p>Monkey依然会发送事件，直到事件计数完成。</p>
<p>7) 参数：  –ignore-security-exceptions</p>
<p>用于指定当应用程序发生许可错误时（如证书许可，网络许可等），Monkey是否停止运行。如果使用此参数，即使应用程序发生许可错误，</p>
<p>Monkey依然会发送事件，直到事件计数完成。</p>
<p>8) 参数：  –kill-process-after-error</p>
<p>用于指定当应用程序发生错误时，是否停止其运行。如果指定此参数，当应用程序发生错误时，应用程序停止运行并保持在当前状态（注意：</p>
<p>应用程序仅是静止在发生错误时的状态，系统并不会结束该应用程序的进程）。</p>
<p>9) 参数：  –monitor-native-crashes</p>
<p>用于指定是否监视并报告应用程序发生崩溃的本地代码。</p>
<p>10) 参数：  –pct-｛+事件类别｝｛+事件类别百分比｝</p>
<p>用于指定每种类别事件的数目百分比（在Monkey事件序列中，该类事件数目占总事件数目的百分比）</p>
<p>参数:</p>
<p>使用说明:</p>
<p>示例:</p>
<p>–pct-touch ｛+百分比｝</p>
<p>调整触摸事件的百分比(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置)</p>
<p>adb shell monkey -p com.htc.Weather–pct-touch 10 1000</p>
<p>–pct-motion ｛+百分比｝</p>
<p>调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)adb shell monkey -p</p>
<p>com.htc.Weather –pct-motion 20 1000</p>
<p>–pct-trackball ｛+百分比｝</p>
<p>调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)</p>
<p>adb shell monkey -p com.htc.Weather–pct-trackball 30 1000</p>
<p>–pct-nav ｛+百分比｝</p>
<p>调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up/down/left/right组成)</p>
<p>adb shell monkey -p com.htc.Weather–pct-nav 40 1000</p>
<p>–pct-majornav ｛+百分比｝</p>
<p>调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键)</p>
<p>adb shell monkey -p com.htc.Weather–pct-majornav 50 1000</p>
<p>–pct-syskeys ｛+百分比｝</p>
<p>调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)</p>
<p>adb shell monkey -p com.htc.Weather–pct-syskeys 60 1000</p>
<p>–pct-appswitch ｛+百分比｝</p>
<p>调整启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法</p>
<p>adb shell monkey -p com.htc.Weather–pct-appswitch 70 1000</p>
<p>–pct-anyevent ｛+百分比｝</p>
<p>调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等</p>
<p>adb shell monkey -p com.htc.Weather</p>
<p>–pct -anyevent 100 1000* 指定多个类型事件的百分比：</p>
<p>adb shell monkey -p com.htc.Weather–pct-anyevent 50 –pct-appswitch 50 1000</p>
<p>注意：各事件类型的百分比总数不能超过100%；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Monkey压力自动化测试&quot;&gt;&lt;a href=&quot;#Monkey压力自动化测试&quot; class=&quot;headerlink&quot; title=&quot;Monkey压力自动化测试&quot;&gt;&lt;/a&gt;Monkey压力自动化测试&lt;/h2&gt;&lt;h3 id=&quot;一、Monkey测试简介&quot;&gt;&lt;a href=&quot;#一、Monkey测试简介&quot; class=&quot;headerlink&quot; title=&quot;一、Monkey测试简介&quot;&gt;&lt;/a&gt;一、Monkey测试简介&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;Monkey测试是Android平台自动化测试的一种手段，通过Monkey程序模拟用户触摸屏幕、滑动Trackball、按键等操作来对设备上的程序进行压力测试，检测程序多久的时间会发生异常。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Monkey" scheme="http://yoursite.com/tags/Monkey/"/>
    
  </entry>
  
  <entry>
    <title>IntentService源码分析</title>
    <link href="http://yoursite.com/2016/07/19/intentservice%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/19/intentservice源码分析/</id>
    <published>2016-07-19T15:50:00.000Z</published>
    <updated>2016-07-26T07:36:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IntentService源码分析"><a href="#IntentService源码分析" class="headerlink" title="IntentService源码分析"></a>IntentService源码分析</h2><hr>
<h3 id="1-概论"><a href="#1-概论" class="headerlink" title="1 概论"></a>1 概论</h3><hr>
<p>IntentService是一种处理异步请求的Service。客户端通过调用<strong><em>Context.startService(Intent)</em></strong>来发送请求，启动Service；Service按需启动后，会依次按顺序处理工作线程中的Intent，并且在工作结束后会自动停止。</p>
<a id="more"></a>
<h3 id="2-IntentService是如何启动一个异步线程处理请求的？"><a href="#2-IntentService是如何启动一个异步线程处理请求的？" class="headerlink" title="2 IntentService是如何启动一个异步线程处理请求的？"></a>2 IntentService是如何启动一个异步线程处理请求的？</h3><hr>
<p>IntentService在创建时，会创建并启动一个线程HandlerThread，并且赋予这个线程一个Looper;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void onCreate() &#123;</div><div class="line">        super.onCreate();</div><div class="line">        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</div><div class="line">        thread.start();</div><div class="line">        mServiceLooper = thread.getLooper();</div><div class="line">        mServiceHandler = new ServiceHandler(mServiceLooper);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>ServiceHandler是Handler的一个子类，用来接受处理消息Message，我们知道一般Handler是在UI主线程接受处理消息的，要想在异步线程接受处理消息，必须给这个异步线程关联一个Looper，并且在异步线程调用Looper.prepare()方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class HandlerThread extends Thread &#123;</div><div class="line">	int mPriority;</div><div class="line">    int mTid = -1;</div><div class="line">    Looper mLooper;</div><div class="line">    </div><div class="line">	public HandlerThread(String name) &#123;</div><div class="line">        super(name);</div><div class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        mTid = Process.myTid();</div><div class="line">        Looper.prepare();</div><div class="line">        synchronized (this) &#123;</div><div class="line">            mLooper = Looper.myLooper();</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">        Process.setThreadPriority(mPriority);</div><div class="line">        onLooperPrepared();</div><div class="line">        Looper.loop();</div><div class="line">        mTid = -1;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-IntentService是如何处理Intent的"><a href="#3-IntentService是如何处理Intent的" class="headerlink" title="3 IntentService是如何处理Intent的"></a>3 IntentService是如何处理Intent的</h3><hr>
<p>调用<strong><em>Context.startService(Intent)</em></strong>后，Service被启动，执行onCreate()方法，然后执行onStart(Intent intent,int startId);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void onStart(Intent intent, int startId) &#123;</div><div class="line">       Message msg = mServiceHandler.obtainMessage();</div><div class="line">       msg.arg1 = startId;</div><div class="line">       msg.obj = intent;</div><div class="line">       mServiceHandler.sendMessage(msg);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到Service开始后，会把Intent对象通过Handler机制交给ServiceHandler来处理，ServiceHandler接受到消息后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private final class ServiceHandler extends Handler &#123;</div><div class="line">       public ServiceHandler(Looper looper) &#123;</div><div class="line">           super(looper);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void handleMessage(Message msg) &#123;</div><div class="line">           onHandleIntent((Intent)msg.obj);</div><div class="line">           stopSelf(msg.arg1);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>ServiceHandler接受到消息后，取出Intent，启动onHandleIntent(Intent) 方法，来处理Intent；</p>
<p>我们来看onHandleIntent(Intent intent);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected abstract void onHandleIntent(Intent intent);</div></pre></td></tr></table></figure>
<p>这是一个抽象方法，留给开发者自己实现，异步操作的实现逻辑都在这个抽象方法里面；操作完成后，通过调用<code>stopSelf()</code>来停止Service。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><hr>
<ol>
<li>IntentService在创建的时候会创建一个线程，并启动这个异步线程；</li>
<li>创建的异步线程会利用Looper、Handler来创建、发送、接受消息Message，与UI主线程通过Handler机制进行线程通信是同理的；</li>
<li>Service的异步操作逻辑是定义在抽象方法onHandleIntent(Intent)里面，开发者需要实现这个抽象方法；</li>
<li>ServiceHandler处理消息是在异步线程里面的，onHandleIntent(Intent)也是运行在异步线程里面的，这与UI主线程里面的Handler不同；</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IntentService源码分析&quot;&gt;&lt;a href=&quot;#IntentService源码分析&quot; class=&quot;headerlink&quot; title=&quot;IntentService源码分析&quot;&gt;&lt;/a&gt;IntentService源码分析&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-概论&quot;&gt;&lt;a href=&quot;#1-概论&quot; class=&quot;headerlink&quot; title=&quot;1 概论&quot;&gt;&lt;/a&gt;1 概论&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;IntentService是一种处理异步请求的Service。客户端通过调用&lt;strong&gt;&lt;em&gt;Context.startService(Intent)&lt;/em&gt;&lt;/strong&gt;来发送请求，启动Service；Service按需启动后，会依次按顺序处理工作线程中的Intent，并且在工作结束后会自动停止。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>内存泄漏常见原因总结</title>
    <link href="http://yoursite.com/2016/07/19/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/07/19/内存泄漏常见原因总结/</id>
    <published>2016-07-19T15:50:00.000Z</published>
    <updated>2016-07-26T07:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存泄漏常见原因总结"><a href="#内存泄漏常见原因总结" class="headerlink" title="内存泄漏常见原因总结"></a>内存泄漏常见原因总结</h2><h3 id="1-非静态内部类的静态实例"><a href="#1-非静态内部类的静态实例" class="headerlink" title="1.非静态内部类的静态实例"></a>1.非静态内部类的静态实例</h3><h3 id="2-Activity的静态成员变量"><a href="#2-Activity的静态成员变量" class="headerlink" title="2.Activity的静态成员变量"></a>2.Activity的静态成员变量</h3><ol>
<li><strong>Drawable</strong></li>
<li><strong>Context</strong></li>
</ol>
<a id="more"></a>
<p>Drawable的对象的内部Callback持有activity的引用，当Activity finish()之后，静态成员drawable始终持有这个Activity的引用，导致内存释放不了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class MainActivityextends Activity</div><div class="line">&#123;</div><div class="line">         static Demo sInstance = null;</div><div class="line">        </div><div class="line">    @Override</div><div class="line">    public void onCreate(BundlesavedInstanceState)</div><div class="line">    &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        if (sInstance == null)</div><div class="line">        &#123;</div><div class="line">           sInstance= new Demo();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    class Demo</div><div class="line">    &#123;</div><div class="line">    voiddoSomething()</div><div class="line">    &#123;</div><div class="line">               System.out.print(&quot;dosth.&quot;);</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Context，Activity内部如果有一个Context的成员变量，将导致Context引用指向的Activity对象释放不了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">	private static Context mContext;</div><div class="line">	</div><div class="line">	public void onCreate(Bundle savedInstanceState)&#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		...</div><div class="line">		mContext=MainActivity.this;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Handler造成的内存泄漏"><a href="#3-Handler造成的内存泄漏" class="headerlink" title="3.Handler造成的内存泄漏"></a>3.Handler造成的内存泄漏</h3><h4 id="3-1-Handler内存泄漏的原因"><a href="#3-1-Handler内存泄漏的原因" class="headerlink" title="3.1 Handler内存泄漏的原因"></a>3.1 Handler内存泄漏的原因</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">	...</div><div class="line">	private Handler mHandler = new Handler()&#123;</div><div class="line">		@Override</div><div class="line">		public void handleMessage(Message msg) &#123;</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家平时开发中喜欢在Activity中直接new一个Handler的匿名内部类，这样造成匿名内部类持有一个外部类(通常是Activity)的引用(不然怎么更新ui)，但是Handler常常伴随着一个执行耗时操作的异步线程(如下载多张图片)，如果在完成耗时操作之前，Activity退出，异步线程持有handler的引用，handler持有Activity的引用，从而导致内存泄漏。</p>
<h4 id="3-2-防止Handler内存泄漏的措施"><a href="#3-2-防止Handler内存泄漏的措施" class="headerlink" title="3.2 防止Handler内存泄漏的措施"></a>3.2 防止Handler内存泄漏的措施</h4><p><strong>通过程序逻辑来进行保护</strong></p>
<ol>
<li>在关闭Activity的时候，把线程也关了；</li>
<li>如果Handler是被delay的Message持有的引用，在Activity的onDestroy()方法中，调用Handler响应书的removeCallbacks()方法，把消息对象从消息队列移除就行了。</li>
</ol>
<p><strong>将Handler声明为静态类</strong></p>
<ul>
<li><p>静态类不持有外部类的引用，所以Activity可以被随意回收，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">private static class MyHandler extends Handler &#123;</div><div class="line">		@Override</div><div class="line">		public void handleMessage(Message msg) &#123;</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>使用弱引用</strong></p>
<p>当Activity在内存中的对象没有任何引用，使用弱引用会让Activity对象很容易被Gc回首。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">private static class MyHandler extends Handler &#123;</div><div class="line">        WeakReference&lt;CrmContactActivity&gt; mReference;</div><div class="line"></div><div class="line">        public MyHandler(CrmContactActivity activity) &#123;</div><div class="line">            mReference = new WeakReference&lt;CrmContactActivity&gt;(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            final CrmContactActivity activity = mReference.get();</div><div class="line">            if (activity == null || activity.isFinishing()) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            if (msg.what == LOAD_MORE) &#123;</div><div class="line">                activity.getCustomersByCompanyName(activity.companyName);</div><div class="line">            &#125; else if (msg.what == THE_END) &#123;</div><div class="line">                activity.showViewIfHasCompanyName((ArrayList&lt;CustomerModel&gt;) activity.matchedCustomerList);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div></pre></td></tr></table></figure>
<h3 id="4-注册某个对象后没有反注册"><a href="#4-注册某个对象后没有反注册" class="headerlink" title="4.注册某个对象后没有反注册"></a>4.注册某个对象后没有反注册</h3><p>广播接收器注册后在Activity退出时忘了反注册，一些利用观察者模式的第三方开源库在使用时，忘了反注册(如EventBus)。<br>正确代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onDestroy() &#123;</div><div class="line">       EventBus.getDefault().unregister(this);</div><div class="line">       super.onDestroy();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="5-集合对象没清理造成的内存泄漏"><a href="#5-集合对象没清理造成的内存泄漏" class="headerlink" title="5.集合对象没清理造成的内存泄漏"></a>5.集合对象没清理造成的内存泄漏</h3><p>把大量对象的引用放入集合中，但我们不需要该对象时，记得从集合中将不需要的引用清理掉，同理，当对象不需要时，记得将对象的引用设置为null。</p>
<h3 id="6-资源文件未关闭"><a href="#6-资源文件未关闭" class="headerlink" title="6.资源文件未关闭"></a>6.资源文件未关闭</h3><p>最常见的是文件流执行完读写操作后，忘记关闭了输入流，输出流；数据库、Content Provider操作完后Cursor忘记了close等等。<br>安全一点的方式是在写代码的时候，首先写完头尾，避免尾部关闭操作忘记了谢。</p>
<h3 id="7-代码不严谨"><a href="#7-代码不严谨" class="headerlink" title="7.代码不严谨"></a>7.代码不严谨</h3><ul>
<li>Bitmap对象使用完后，忘记了调用recycle()方法销毁；</li>
<li>解析图片的时候忘记了设置采样率</li>
<li>自定义View时TypedArray使用完后忘记调用recycle()方法释放内存</li>
<li>ListView的适配器类中没有复用convertView</li>
<li>未采用软引用等</li>
</ul>
<h3 id="8-关于内存泄漏的调试"><a href="#8-关于内存泄漏的调试" class="headerlink" title="8.关于内存泄漏的调试"></a>8.关于内存泄漏的调试</h3><p>我有一篇博客介绍我开发过程中一次典型的内存泄漏案例，这个案例中介绍了内存泄漏检测工具MAT的使用，博客链接如下：</p>
<p><a href="http://blog.csdn.net/u012464435/article/details/50034349" target="_blank" rel="external">MAT使用案例</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存泄漏常见原因总结&quot;&gt;&lt;a href=&quot;#内存泄漏常见原因总结&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏常见原因总结&quot;&gt;&lt;/a&gt;内存泄漏常见原因总结&lt;/h2&gt;&lt;h3 id=&quot;1-非静态内部类的静态实例&quot;&gt;&lt;a href=&quot;#1-非静态内部类的静态实例&quot; class=&quot;headerlink&quot; title=&quot;1.非静态内部类的静态实例&quot;&gt;&lt;/a&gt;1.非静态内部类的静态实例&lt;/h3&gt;&lt;h3 id=&quot;2-Activity的静态成员变量&quot;&gt;&lt;a href=&quot;#2-Activity的静态成员变量&quot; class=&quot;headerlink&quot; title=&quot;2.Activity的静态成员变量&quot;&gt;&lt;/a&gt;2.Activity的静态成员变量&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Drawable&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>一次Dialog导致的内存泄漏</title>
    <link href="http://yoursite.com/2016/07/19/%E4%B8%80%E6%AC%A1dialog%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2016/07/19/一次dialog导致的内存泄漏/</id>
    <published>2016-07-19T15:50:00.000Z</published>
    <updated>2016-07-26T07:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一次Dialog导致的内存泄漏"><a href="#一次Dialog导致的内存泄漏" class="headerlink" title="一次Dialog导致的内存泄漏"></a>一次Dialog导致的内存泄漏</h2><p>今天上午10：30来到公司后，一头扎进了张鸿洋大神所写的OkHttpUtils源码中去，继续昨晚未完成的任务，11:30后，终于对整个框架有了一个比较全局、清晰的了解，心里更是对大神充满满满的崇拜和敬意；然后回到公司的工作，打开jira，发现距离我两个工位的美女测试姐姐给我提了一个页面刷新bug，卧槽，居然还有bug，赶紧拿起数据线，插上Mac电脑和华为荣耀6手机，进入bug页面，执行相关操作，程序按正常逻辑自动退出进入上一层页面，检查应该刷新的两个页面，发现通过EventBus通知刷新的页面都刷新了，没问题啊，嗯嗯…?好像刚才执行点击操作时，在页面退出之前，手机屏幕好像出现了短暂的黑屏现象，确认应该没看错，赶紧打开Android Studio的log日志，发现如下：</p>
<a id="more"></a>
<p><img src="http://img.blog.csdn.net/20160303232609504" alt="error_log"></p>
<p>我靠，居然发生了内存泄漏，按照日志调用栈的信息，应该是Activity在退出finish后，Dialog仍然持有Activity的引用，从而导致内存泄漏。<br>但是我明明已经调用了dialog.dismiss()方法了，这个Dialog与Activity应该没有关联引用了，怎么仍然持有引用？<br>下面是执行点击操作，弹出Dialog的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">final TitleContentDialog dialog = new TitleContentDialog(ReceivableMoneyRecordActivity.this);</div><div class="line">                        dialog.setContentView(getContentViewForDialog(&quot;确认删除此回款记录?&quot;));</div><div class="line">                        dialog.setTitle(null);</div><div class="line">                        dialog.setCancelButton(&quot;取消&quot;, new View.OnClickListener() &#123;</div><div class="line">                            @Override</div><div class="line">                            public void onClick(View v) &#123;</div><div class="line">                                dialog.dismiss();</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                        dialog.setConfirmButton(&quot;确定&quot;, new View.OnClickListener() &#123;</div><div class="line">                            @Override</div><div class="line">                            public void onClick(View v) &#123;</div><div class="line">                                dialog.dismiss();</div><div class="line">                                deleteRecord();</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                        dialog.show();</div></pre></td></tr></table></figure>
<p>可以看出点击确定后，dialog先是dismiss()，然后执行deleteRecord()方法，deleteRecord()里面执行请求网络的删除操作。</p>
<p>打开浏览器，输入问题，都说是Activity finish时，Dialog仍然可见，要在Activity的onDestroy()方法中，确保已经关闭了Dialog，<br>OK，那我就在onDestroy()方法里面校验Dialog，我把Dialog提取出方法，成为Activity的一个成员变量mDeleteDialog;<br>同时重写Activity的onDestroy()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Override</div><div class="line">protected void onDestroy() &#123;</div><div class="line">    //防止内存泄漏</div><div class="line">    if (mDeleteDialog.isShowing()) &#123;</div><div class="line">        mDeleteDialog.dismissImmediately();</div><div class="line">    &#125;</div><div class="line">    mDeleteDialog = null;</div><div class="line">    super.onDestroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>点击Android Studio的运行按钮，apk重新运行，再次进入问题页面，执行删除操作，黑屏事件再次发生，(^|_|^)<br>是谁？是谁？到底是谁窃取了我的Activity？</p>
<p>冷静了几秒，首先要肯定Activity在finish的时候，Dialog仍然持有Activity引用的真相。<br>为什么Dialog还持有Activity的引用？我明明在finish之前，就调用了Dialog的dismiss()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mDeleteDialog.setConfirmButton(&quot;确定&quot;, new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                mDeleteDialog.dismiss();</div><div class="line">                deleteRecord();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>进入Dialog的dismiss()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	public void dismiss() &#123;</div><div class="line">		if (mActivity.isFinishing()) &#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		mDialogView.dismiss(new OnDialogDismissListener() &#123;</div><div class="line">			@Override</div><div class="line">			public void onFinish() &#123;</div><div class="line">				dismissImmediately();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>mDialogView是一个自定义View，继承自RelativeLayout</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 自定义标题、内容的Dialog容器</div><div class="line"> */</div><div class="line">public class TitleContentDialog extends Dialog &#123;</div><div class="line">	/** 宿主 */</div><div class="line">	private Activity mActivity;</div><div class="line">	/** 实际显示的加载视图 */</div><div class="line">	private CustomTitleContentDialogView mDialogView;</div><div class="line">	...</div><div class="line">	</div><div class="line">	private class CustomTitleContentDialogView extends RelativeLayout &#123;</div><div class="line">		/*</div><div class="line">		 * 显示配置及动画配置部分</div><div class="line">		 */</div><div class="line"></div><div class="line">		/** 对话框占比 */</div><div class="line">		private static final float RATIO = 0.75f;</div><div class="line">		/** 动画执行时间 */</div><div class="line">		private static final float ANIM_DUTAION = 200;</div><div class="line">		...</div><div class="line">		/** 动画执行器 */</div><div class="line">		private AnimRunnable mAnimRunnable;</div><div class="line">		...</div><div class="line">		/**</div><div class="line">		 * 隐藏加载</div><div class="line">		 */</div><div class="line">		public void dismiss(OnDialogDismissListener listener) &#123;</div><div class="line">			mDismissListener = listener;</div><div class="line">			mAnimRunnable.setAnimState(AnimState.DISMISSING);</div><div class="line">		&#125;</div><div class="line">		...</div><div class="line">		/**</div><div class="line">		 * 动画执行器</div><div class="line">		 * </div><div class="line">		 * </div><div class="line">		 */</div><div class="line">		private class AnimRunnable implements Runnable &#123;</div><div class="line">			...</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				...</div><div class="line">				if (mAnimState != AnimState.NORMAL) &#123;</div><div class="line">					if (mCurrentFrame &lt; mTotalFrame) &#123;</div><div class="line">						mCurrentFrame++;</div><div class="line">					&#125; else &#123;</div><div class="line">						if (mAnimState == AnimState.SHOWING) &#123;</div><div class="line">							if (mNextState == AnimState.NONE) &#123;</div><div class="line">								setAnimState(AnimState.NORMAL);</div><div class="line">							&#125; else &#123;</div><div class="line">								reset();</div><div class="line">								setAnimState(AnimState.DISMISSING);</div><div class="line">							&#125;</div><div class="line">						&#125; else if (mAnimState == AnimState.DISMISSING) &#123;</div><div class="line">							reset();</div><div class="line">							if (mDismissListener != null) &#123;</div><div class="line">								mDismissListener.onFinish();</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				...</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 消失动画结束后的回调接口</div><div class="line">	 */</div><div class="line">	private interface OnDialogDismissListener &#123;</div><div class="line">		/** 动画执行完毕 */</div><div class="line">		void onFinish();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，自定义的Dialog在执行重写的dismiss()方法时，先运行一段动画，动画执行完成后，再通过回调执行dismissImmediately()方法；<br>dismissImmediately()方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">	 * 立即关闭</div><div class="line">	 */</div><div class="line">	public void dismissImmediately() &#123;</div><div class="line">		if (isShowing() &amp;&amp; !mActivity.isFinishing()) &#123;</div><div class="line">			Utils.hideInputMethod(mActivity);</div><div class="line">			TitleContentDialog.super.dismiss();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>dismissImmediately()方法才会让Dialog立即消失，从而与Activity解除绑定；<br>在dismissImmediately()方法里面设置断点debug，发现程序没有执行if语句里面的代码；if条件里面的isShowing()是true，这是毫无疑问的，<br>那就是<code>!mActivity.isFinishing()</code>不满足条件，也就是说此时的Activity已经执行完网络操作，运行了finish()方法。</p>
<p>整理一遍思绪，发现造成Dialog没有消失，而Activity已经finish的原因是Dialog消失时执行的动画，通过不断调用View.postDelayed(Runnable action,long delayMillis)方法，达到Dialog消失时渐变缩放的动画效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public boolean postDelayed(Runnable action, long delayMillis) &#123;</div><div class="line">       final AttachInfo attachInfo = mAttachInfo;</div><div class="line">       if (attachInfo != null) &#123;</div><div class="line">           return attachInfo.mHandler.postDelayed(action, delayMillis);</div><div class="line">       &#125;</div><div class="line">       // Assume that post will succeed later</div><div class="line">       ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>原来调用了Handler.postDelayed()方法，熟悉Android开发应该了解Handler很容易造成Activity发生内存泄漏，不知道的同学可以看我的另一篇博客<a href="http://blog.csdn.net/u012464435/article/details/50753246" target="_blank" rel="external">内存泄漏常见原因总结</a>。<br>动画一共执行了200毫秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/** 动画执行时间 */</div><div class="line">private static final float ANIM_DUTAION = 200;</div></pre></td></tr></table></figure>
<p>也就是说，在Dialog执行动画的200毫秒期间，Activity执行的网络操作已经结束，Activity运行finish()方法，但是Dialog在执行动画，还没消失，仍然持有Activity的引用，从而导致内存泄漏。</p>
<p>要解决这个问题，只要保证Activity运行finish()方法在Dialog执行完动画之后，由于网络请求的事件不确定，finish()方法只需要延迟200毫秒，就可以保证Activity的运行finish()方法在Dialog动画结束之后。</p>
<p>下面是网络请求执行完后的回调操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">                public void OnRemoteApiFinish(BasicResponse response) &#123;</div><div class="line">                    if (response.status == BasicResponse.SUCCESS) &#123;</div><div class="line">                        Toast.makeText(ReceivableMoneyRecordActivity.this, &quot;删除回款记录成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                        EventBus.getDefault().post(new OnReceivableRecordListChangedEvent());</div><div class="line">                        finish();</div><div class="line">                    &#125; else &#123;</div><div class="line">                        Toast.makeText(ReceivableMoneyRecordActivity.this, response.msg, Toast.LENGTH_SHORT).show();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<p>finish()方法延时几百毫秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">            public void OnRemoteApiFinish(BasicResponse response) &#123;</div><div class="line">                if (response.status == BasicResponse.SUCCESS) &#123;</div><div class="line">                    Toast.makeText(ReceivableMoneyRecordActivity.this, &quot;删除回款记录成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    _Application.getInstance().scheduleTask(new Runnable() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void run() &#123;</div><div class="line">                            EventBus.getDefault().post(new OnReceivableRecordListChangedEvent());</div><div class="line">                            finish();</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125; else &#123;</div><div class="line">                    Toast.makeText(ReceivableMoneyRecordActivity.this, response.msg, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>调用了Application里面的scheduleTask(Runnable action)方法，达到延时500毫秒的目的。</p>
<p>启动Android studio，打开手机再次进入问题页面，执行删除操作，弹出确认Dialog，点击确认，退出，没有黑屏现象，问题终于解决了。</p>
<p>为了确保Dialog不会再导致内存泄漏，多测试几次，反复点击确认和取消按钮，我擦，第二次点击取消按钮，居然又出现黑屏现象，继续追踪，发现问题所在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void show() &#123;</div><div class="line">	if (mActivity.isFinishing()) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	super.show();</div><div class="line"></div><div class="line">	new Handler().postDelayed(new Runnable() &#123;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			if (!mActivity.isFinishing())</div><div class="line">				mDialogView.show();</div><div class="line">		&#125;</div><div class="line">	&#125;, 200);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定位到Handler.postDelayed()方法，这里发生了内存泄漏，这里为什么发生内存泄漏？暂时没找到确切原因，把Activity里面的全局变量Dialog还原，每次点击删除的时候，再new一个Dialog，这个问题又没了，现在猜测跟Message有关，但还是没想明白是哪个对象需要释放内存，但又被引用。<br>困…,已经到晚上11点了，明天再弄清原因。<br>明天打算把<a href="http://blog.csdn.net/u012464435/article/details/50774580" target="_blank" rel="external">一个内存泄漏引发的血案</a>给阅读一下，彻底理清这里面的缘由。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一次Dialog导致的内存泄漏&quot;&gt;&lt;a href=&quot;#一次Dialog导致的内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;一次Dialog导致的内存泄漏&quot;&gt;&lt;/a&gt;一次Dialog导致的内存泄漏&lt;/h2&gt;&lt;p&gt;今天上午10：30来到公司后，一头扎进了张鸿洋大神所写的OkHttpUtils源码中去，继续昨晚未完成的任务，11:30后，终于对整个框架有了一个比较全局、清晰的了解，心里更是对大神充满满满的崇拜和敬意；然后回到公司的工作，打开jira，发现距离我两个工位的美女测试姐姐给我提了一个页面刷新bug，卧槽，居然还有bug，赶紧拿起数据线，插上Mac电脑和华为荣耀6手机，进入bug页面，执行相关操作，程序按正常逻辑自动退出进入上一层页面，检查应该刷新的两个页面，发现通过EventBus通知刷新的页面都刷新了，没问题啊，嗯嗯…?好像刚才执行点击操作时，在页面退出之前，手机屏幕好像出现了短暂的黑屏现象，确认应该没看错，赶紧打开Android Studio的log日志，发现如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Dialog" scheme="http://yoursite.com/tags/Dialog/"/>
    
      <category term="内存泄漏" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Zsh常见快捷键</title>
    <link href="http://yoursite.com/2016/07/19/zsh%E5%B8%B8%E8%A7%81%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2016/07/19/zsh常见快捷键/</id>
    <published>2016-07-19T15:50:00.000Z</published>
    <updated>2016-07-26T07:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zsh常见快捷键"><a href="#Zsh常见快捷键" class="headerlink" title="Zsh常见快捷键"></a>Zsh常见快捷键</h2><a id="more"></a>
<ol>
<li><strong>ctrl + a</strong>        到行首</li>
<li><strong>ctrl + e</strong>        到行末</li>
<li><strong>ctrl + u</strong>     直接清除本行</li>
<li><strong>ctrl + f/b</strong>    前进后退，相当于左右方向键，但是显然比移开手按方向键更快</li>
<li><strong>ctrl + p</strong>        上一条命令，相当于 <em>方向键上</em></li>
<li><strong>ctrl + h</strong>        删除之前的字符</li>
<li><strong>ctrl + w</strong>        删除光标前的单词</li>
<li><strong>ctrl + k</strong>        删除到文本末尾</li>
<li><strong>ctrl + p</strong>        搜索命令历史</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Zsh常见快捷键&quot;&gt;&lt;a href=&quot;#Zsh常见快捷键&quot; class=&quot;headerlink&quot; title=&quot;Zsh常见快捷键&quot;&gt;&lt;/a&gt;Zsh常见快捷键&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Handler消息处理机制源码解析</title>
    <link href="http://yoursite.com/2016/07/19/handler:message:looper%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/07/19/handler:message:looper机制/</id>
    <published>2016-07-19T15:50:00.000Z</published>
    <updated>2016-07-30T14:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Handler消息处理机制源码解析"><a href="#Handler消息处理机制源码解析" class="headerlink" title="Handler消息处理机制源码解析"></a>Handler消息处理机制源码解析</h2><h3 id="Handler作用"><a href="#Handler作用" class="headerlink" title="Handler作用"></a>Handler作用</h3><p>android开发过程中，我们都知道在一个异步线程中完成一段耗时操作，利用handler把结果send到UI主线程，从而更新ui；Android应用在初始化启动时，在ActivityThread中也定义了一个Handler的派生类H，用来进行Activity和Service生命周期的管理等；</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private class H extends Handler &#123;</div><div class="line">	...//省略</div><div class="line">	public void handleMessage(Message msg) &#123;</div><div class="line">            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</div><div class="line">            switch (msg.what) &#123;</div><div class="line">                case LAUNCH_ACTIVITY: &#123;</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</div><div class="line">                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</div><div class="line">                    r.packageInfo = getPackageInfoNoCheck(</div><div class="line">                            r.activityInfo.applicationInfo, r.compatInfo);</div><div class="line">                    handleLaunchActivity(r, null);</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                &#125; break;</div><div class="line">                case RELAUNCH_ACTIVITY: &#123;</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityRestart&quot;);</div><div class="line">                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;</div><div class="line">                    handleRelaunchActivity(r);</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                &#125; break;</div><div class="line">                case PAUSE_ACTIVITY:</div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;);</div><div class="line">                    handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&amp;1) != 0, msg.arg2,</div><div class="line">                            (msg.arg1&amp;2) != 0);</div><div class="line">                    maybeSnapshot();</div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">                    break;</div><div class="line">                ...</div><div class="line">                &#125;</div><div class="line">            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + codeToString(msg.what));</div><div class="line">        &#125;</div><div class="line">	...//省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Message的send机制"><a href="#Message的send机制" class="headerlink" title="Message的send机制"></a>Message的send机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessage(Message msg)</div><div class="line">   &#123;</div><div class="line">       return sendMessageDelayed(msg, 0);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>往下追踪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</div><div class="line">   &#123;</div><div class="line">       if (delayMillis &lt; 0) &#123;</div><div class="line">           delayMillis = 0;</div><div class="line">       &#125;</div><div class="line">       return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>继续往下追踪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">       MessageQueue queue = mQueue;</div><div class="line">       if (queue == null) &#123;</div><div class="line">           RuntimeException e = new RuntimeException(</div><div class="line">                   this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">           Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line">       return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个方法中我们大致可以看出消息Message是进入一个队列mQueue当中，mQueue是Handler实例化时，从UI主线程里面的Looper中获取到的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">       ...//省略</div><div class="line">       mLooper = Looper.myLooper();</div><div class="line">       if (mLooper == null) &#123;</div><div class="line">           throw new RuntimeException(</div><div class="line">               &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">       &#125;</div><div class="line">       mQueue = mLooper.mQueue;</div><div class="line">       mCallback = callback;</div><div class="line">       mAsynchronous = async;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>每个线程只能对应一个Looper，UI主线程中的Looper在应用中是全局的，所有Message发送后都存储在这个Looper的MessageQueue中</p>
<p>继续往下看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">       msg.target = this;</div><div class="line">       if (mAsynchronous) &#123;</div><div class="line">           msg.setAsynchronous(true);</div><div class="line">       &#125;</div><div class="line">       return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>以上这些都发生在Handler中，下面进入MessageQueue，看看消息Message是如何进入队列的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">	//处理消息msg的Handler不能为空，所有的消息最终还是交给Handler处理的</div><div class="line">       if (msg.target == null) &#123;</div><div class="line">           throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">       &#125;</div><div class="line">       //如果消息msg正在使用中，无需继续执行下去，同时抛出一个异常</div><div class="line">       if (msg.isInUse()) &#123;</div><div class="line">           throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       synchronized (this) &#123;</div><div class="line">       	//判断MessageQueue是否已停止，停止抛出一个所在线程死亡的异常</div><div class="line">           if (mQuitting) &#123;</div><div class="line">               IllegalStateException e = new IllegalStateException(</div><div class="line">                       msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">               Log.w(TAG, e.getMessage(), e);</div><div class="line">               msg.recycle();</div><div class="line">               return false;</div><div class="line">           &#125;</div><div class="line">		//标志这个消息正在使用中</div><div class="line">           msg.markInUse();</div><div class="line">           msg.when = when;</div><div class="line">           Message p = mMessages;</div><div class="line">           boolean needWake;</div><div class="line">           //如果在队列中msg前面没有其他消息或者msg不是最新的消息，把当前msg放入队列的头部，如果队列是阻塞状态就唤醒队列</div><div class="line">           if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">               // New head, wake up the event queue if blocked.</div><div class="line">               msg.next = p;</div><div class="line">               mMessages = msg;</div><div class="line">               needWake = mBlocked;</div><div class="line">           &#125; else &#123;//找到合适的位置把msg放入到队列中</div><div class="line">               // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class="line">               // up the event queue unless there is a barrier at the head of the queue</div><div class="line">               // and the message is the earliest asynchronous message in the queue.</div><div class="line">               needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">               Message prev;</div><div class="line">               for (;;) &#123;</div><div class="line">                   prev = p;</div><div class="line">                   p = p.next;</div><div class="line">                   //队列中没有更多消息，跳出死循环</div><div class="line">                   if (p == null || when &lt; p.when) &#123;</div><div class="line">                       break;</div><div class="line">                   &#125;</div><div class="line">                   if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                       needWake = false;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               msg.next = p; // invariant: p == prev.next</div><div class="line">               prev.next = msg;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">           if (needWake) &#123;</div><div class="line">               nativeWake(mPtr);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="Handler是如何拿到Message的"><a href="#Handler是如何拿到Message的" class="headerlink" title="Handler是如何拿到Message的"></a>Handler是如何拿到Message的</h3><p>应用在启动初始化时，在ActivityThread中开启了一个无限循环检查的操作，当有新的Message时，就从消息队列中MessageQueue中拿出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line">       final Looper me = myLooper();</div><div class="line">       if (me == null) &#123;</div><div class="line">           throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">       &#125;</div><div class="line">       final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">       // Make sure the identity of this thread is that of the local process,</div><div class="line">       // and keep track of what that identity token actually is.</div><div class="line">       Binder.clearCallingIdentity();</div><div class="line">       final long ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">       for (;;) &#123;</div><div class="line">           Message msg = queue.next(); // 有可能阻塞</div><div class="line">           if (msg == null) &#123;</div><div class="line">               // msg为空说明队列已经停止不可用，不执行后面的操作了</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           // This must be in a local variable, in case a UI event sets the logger</div><div class="line">           Printer logging = me.mLogging;</div><div class="line">           if (logging != null) &#123;</div><div class="line">               logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                       msg.callback + &quot;: &quot; + msg.what);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">		//把消息msg交给它的目标Handler来分配处理消息，消息在哪个页面中处理就是通过Message中的target来确定是哪个Activity中的Handler，从而在正确页面中处理msg</div><div class="line">           msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">           if (logging != null) &#123;</div><div class="line">               logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           // Make sure that during the course of dispatching the</div><div class="line">           // identity of the thread wasn&apos;t corrupted.</div><div class="line">           final long newIdent = Binder.clearCallingIdentity();</div><div class="line">           if (ident != newIdent) &#123;</div><div class="line">               Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</div><div class="line">                       + Long.toHexString(ident) + &quot; to 0x&quot;</div><div class="line">                       + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</div><div class="line">                       + msg.target.getClass().getName() + &quot; &quot;</div><div class="line">                       + msg.callback + &quot; what=&quot; + msg.what);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           msg.recycleUnchecked();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>Handler调用dispatchMessage(msg)来处理消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">       if (msg.callback != null) &#123;</div><div class="line">           handleCallback(msg);</div><div class="line">       &#125; else &#123;</div><div class="line">           if (mCallback != null) &#123;</div><div class="line">               if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                   return;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           handleMessage(msg);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>我们终于看到熟悉的handleMessage()了</p>
<h3 id="Handler消息机制UML图"><a href="#Handler消息机制UML图" class="headerlink" title="Handler消息机制UML图"></a>Handler消息机制UML图</h3><p><img src="http://pic002.cnblogs.com/images/2012/328668/2012060815461921.jpg" alt="img_handler_uml"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Handler消息处理机制源码解析&quot;&gt;&lt;a href=&quot;#Handler消息处理机制源码解析&quot; class=&quot;headerlink&quot; title=&quot;Handler消息处理机制源码解析&quot;&gt;&lt;/a&gt;Handler消息处理机制源码解析&lt;/h2&gt;&lt;h3 id=&quot;Handler作用&quot;&gt;&lt;a href=&quot;#Handler作用&quot; class=&quot;headerlink&quot; title=&quot;Handler作用&quot;&gt;&lt;/a&gt;Handler作用&lt;/h3&gt;&lt;p&gt;android开发过程中，我们都知道在一个异步线程中完成一段耗时操作，利用handler把结果send到UI主线程，从而更新ui；Android应用在初始化启动时，在ActivityThread中也定义了一个Handler的派生类H，用来进行Activity和Service生命周期的管理等；&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>欢迎使用 Cmd Markdown 编辑阅读器</title>
    <link href="http://yoursite.com/2016/07/19/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8_cmd_markdown_%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8/"/>
    <id>http://yoursite.com/2016/07/19/欢迎使用_cmd_markdown_编辑阅读器/</id>
    <published>2016-07-19T15:50:00.000Z</published>
    <updated>2016-07-26T07:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>
<a id="more"></a>
<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p>
<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>
<h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="external">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>
<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>
</blockquote>
<hr>
<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>
<h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="external">Todo 列表</a></h3><ul>
<li>[ ] 支持以 PDF 格式导出文稿</li>
<li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li>[x] 新增 Todo 列表功能</li>
<li>[x] 修复 LaTex 公式渲染问题</li>
<li>[x] 新增 LaTex 公式编号功能</li>
</ul>
<h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>
<h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># A comment</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="external">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: Start</div><div class="line">op=&gt;operation: Your Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="external">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Alice-&gt;Bob: Hello Bob, how are you?</div><div class="line">Note right of Bob: Bob thinks</div><div class="line">Bob--&gt;Alice: I am good thanks!</div></pre></td></tr></table></figure>
<h3 id="6-绘制表格"><a href="#6-绘制表格" class="headerlink" title="6. 绘制表格"></a>6. 绘制表格</h3><table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="7-更详细语法说明"><a href="#7-更详细语法说明" class="headerlink" title="7. 更详细语法说明"></a>7. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="external">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="external">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>
<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>
<hr>
<h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>
<h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>
<h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p>
<h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右测的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>
<h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>
<h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>
<h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p>
<p>通过管理工具栏可以：</p>
<p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>
<h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p>
<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>
<p>工具栏上的五个图标依次为：</p>
<p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>
<h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>
<h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>
<p>标签： 未分类</p>
<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>
<p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p>
<h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>
<hr>
<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="external">@ghosert</a><br>2015 年 06月 15日    </p>
<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax</a> 参考更多使用方法。</p>
<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;欢迎使用-Cmd-Markdown-编辑阅读器&quot;&gt;&lt;a href=&quot;#欢迎使用-Cmd-Markdown-编辑阅读器&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用 Cmd Markdown 编辑阅读器&quot;&gt;&lt;/a&gt;欢迎使用 Cmd Markdown 编辑阅读器&lt;/h1&gt;&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>插件化-资源处理(公司技术分享)</title>
    <link href="http://yoursite.com/2016/07/13/%E6%8F%92%E4%BB%B6%E5%8C%96-%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/07/13/插件化-资源处理/</id>
    <published>2016-07-12T16:19:52.000Z</published>
    <updated>2016-08-22T02:53:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插件化-资源处理"><a href="#插件化-资源处理" class="headerlink" title="插件化-资源处理"></a>插件化-资源处理</h2><p>写的比较长，可以选择跳过前面2节，直接从<strong>0x03实例分析</strong>开始。如有错误，请不吝指正。</p>
<h3 id="0x00-aapt编译流程"><a href="#0x00-aapt编译流程" class="headerlink" title="0x00 aapt编译流程"></a>0x00 aapt编译流程</h3><p>在之前的Apk编译打包过程分析中，我们使用了一个google提供的一个工具，aapt。主要有两个用途，第一，在编译代码之前通过aapt生成R.java文件。第二，在编译完成代码之后，通过aapt打包所有的资源生成apk。下面我们来简单分析一下aapt是如何进行这两项工作的。</p>
<h4 id="aapt需要干什么？"><a href="#aapt需要干什么？" class="headerlink" title="aapt需要干什么？"></a>aapt需要干什么？</h4><p>aapt主要需要做以下这些事情：</p>
<p><em>1.编译xml文件</em> </p>
<p>编译成二进制的xml文件会加快运行时的解析速度。</p>
<p><em>2.生成R.java/R.txt</em> </p>
<p>aapt在编译的过程中分析收集所有的资源文件，除了assets文件夹下的文件外，其他所有的资源都会分配一个唯一的id，并写入R文件中，这样我们就可以通过R.xx.xxxx的方法在代码中访问资源了。</p>
<p><em>3.生成resource.arsc</em> </p>
<p>arsc文件其实就是一份资源文件的索引，因为在资源中除了文本形式的xml文件以外还有很多非文本类型的资源，例如图片，要获取这些资源，我们需要通过arsc找到他们的存储路径。</p>
<h4 id="Aapt的编译流程"><a href="#Aapt的编译流程" class="headerlink" title="Aapt的编译流程"></a>Aapt的编译流程</h4><p>如果我们略过aapt实际运行时复杂的流程，那么资源处理可以简化成以下过程</p>
<p><img src="http://i4.piimg.com/567571/b3837e2058d1ca27.png" alt=""></p>
<p>其中涉及到了两个关键的数据结构，<code>AaptAssets</code>和<code>ResourceTable</code>，从源码中可以得到这两个结构以及相关类的UML图，如下：</p>
<p><img src="http://img.my.csdn.net/uploads/201304/03/1364933259_8915.jpg" alt="AaptAssets"></p>
<p><img src="http://img.my.csdn.net/uploads/201304/08/1365361779_6191.jpg" alt="ResourceTable"></p>
<p>上面的图可能有些抽象，我们通过一个例子看一下，假设<code>res</code>目录下有一下资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-drawable</div><div class="line">    -a.png</div><div class="line">-drawable-xhdpi</div><div class="line">    -a.png</div><div class="line">-drawable-xxhdpi</div><div class="line">    -a.png</div><div class="line">-layout</div><div class="line">    -main_layout.xml</div><div class="line">    -detail_layout.xml</div><div class="line">-values</div><div class="line">    -attrs.xml</div><div class="line">    -strings.xml</div></pre></td></tr></table></figure>
<p>那么，在收集资源阶段AaptAssets的结构类似下面的json字符串</p>
<p><img src="http://i4.piimg.com/567571/73da640476d2320f.png" alt="AaptAssets的结构示意图"></p>
<p>接下来，aapt为每一个收集到资源分配资源id，这个过程中有以下几个地方需要注意：</p>
<ol>
<li>values文件下的资源会被编译成最终值放入resource.arsc。例如colors.xml中，<code>&lt;color name=&quot;background&quot;&gt;#2888e5&lt;/color&gt;</code>会被编译成类似<code>[typeoffset:0x02,keyoffset:0x12,value:0xff2888e5]</code>这样的三元组用来在resource.arsc中定位它的值</li>
<li>类似drawable这样的非文本类型的资源，它的值是它在res目录下的相对路径，并不是它的二进制值</li>
<li>attr中的内容会被编译成带有层级的结构，类似<code>[typeoffset:0x01,keyoffset:0x14,parentStart:0x3f,valueoffset=0x0f2]</code></li>
</ol>
<p>我们还是通过上面提到的例子来看一下ResourceTable的结构，如图</p>
<p><img src="http://i1.piimg.com/567571/37daaaf2f46c5107.png" alt="ResourceTable的结构示意图"></p>
<p>我们知道一个资源的id是一个32位整数，其中前8位是packageID，之后的8位是typeID，最后16位是具体资源的ID，也就是如下的形式：</p>
<p><code>0xPPTTEEEE</code></p>
<p>其中，packageID和typeID在resources.arsc中是确实存在的，但是具体资源ID在arsc中并不存在，它的含义其实是某一个具体资源在当前package，当前Type下的index值。packageId的取值范围是[0x01,0x7f],其中，0x01是系统资源的packageId，应用程序的packageId始终是0x7f，这个特性需要重点关注一下，因为接下来的一些黑科技就是从这里诞生的。typeID虽然在arsc文件中真是存在，但是不要认为它的取值是一个枚举，它和具体资源id一样，表示一个资源类型在当前package下的index值，它的值是从1开始的。</p>
<p>分配完资源id后，接下来要对所有的xml文件进行编译，这里的xml文件不包括values中的文件。编译的具体过程，这里略过不谈，只简单的分析一下思路，大致是这样的，首先读取一个xml文件，在内存中，这个xml文件以一棵树的形式存在，然后遍历这棵树，将所有具有资源id的属性名和属性值换成id，然后收集所有的字符串，写入字符串常量池，xml中对字符串的引用全部换成对常量池的索引，之后压平这棵将树，最后将处理后的结构写入文件就完成了一个xml文件的编译，具体的过程当然要比这个复杂很多，但是我们要理解这样做的原因，第一，通过字符串常量池处理所有的字符串能够过滤重复的字符串，减少xml的体积。第二，对于有资源id的属性名和属性值直接替换成id之后能够加快运行时对xml文件的解析。对xml文件的处理有点类似dex文件压缩class文件的方式，都是抽取重复的内容，然后通过索引来引用这些重复的内容。</p>
<p>将所有的xml文件都编译完成后，就可以输出resources.arsc 和 R.java 文件了，由于在之前的步骤中，我们已经将所有的资源保存在了ResourceTable这个结构中，那么接下来只需要遍历这个结构，按照资源出现的顺序将最终的资源id写入R.java,然后按照arsc文件的结构把ResourceTable中的内容写入文件就得到了resource.arsc文件。需要注意一点，arsc文件的结构并不是aapt定义的，而是由Android系统源码中的AssetManager定义，因为这份文件最终是由AssetManager来读取和解析的。</p>
<h3 id="0x01-resources-arsc-结构分析"><a href="#0x01-resources-arsc-结构分析" class="headerlink" title="0x01 resources.arsc 结构分析"></a>0x01 resources.arsc 结构分析</h3><p>我们通过ResourceTypes.h 的定义来分析arsc的结构，为什么不通过aapt创建它的过程来分析呢，因为aapt的代码实在太难读。。。</p>
<p>arsc文件的结构如图所示</p>
<p><img src="http://i2.piimg.com/567571/3efd8cca9f242183.png" alt="arsc文件结构"></p>
<p>其中ResTable_typeSpec结构描述了资源的类型，例如drawable，layout。<br>ResTable_type结构描述了不同相同类型的资源在不同的维度下的配置，这里的维度指的就是Android平台提供的资源适配机制，比如drawable-xhdpi,drawable-xxhdpi描述的是屏幕密度，layout-v19,layout-v21描述的是系统版本，Android系统一共提供了18个维度来进行资源适配，具体的内容可以参考文档。AssetManager会根据实际运行时的设备信息匹配到最合适的资源。entry结构描述的是具体的资源项，在不同的 <code>ResTable_type</code>下的一组entry是同名资源在不同维度下的不同文件。理论上每一个<br><code>ResTable_type</code>下包含有相同个数的entry，但是实际上并不会这样，因为我们往往只针对部分资源做了不同维度的区分，这意味着每一个type下的entry数组是不等长的，对于这样的情况，AssetManager有一套机制来对维度进行剪裁，具体算法可以参考文档。</p>
<p>注意一点，值字符串常量池没有根据包名进行区分，所有包中的资源的值字符串都会进入这个区域。而其他的区域是根据包名进行区分的，但是很奇怪的一点是，在我的测试中，无论是使用gradle进行构建，还是直接使用aapt打包，都无法做到在resource.arsc中包含多个package。使用gradle时只包含一个包这个很好理解，因为gradle在调用aapt之前已经将多个包中的资源进行合并，aapt接受到的参数中只有一个包。但是使用aapt的–auto-overlay和–extra-packages参数依然只包含一个包，让我很困惑，后续还会继续阅读aapt的代码查找原因。</p>
<p>对于编译时资源文件的处理就分析到这，省略了很多细节，对具体的细节感兴趣的话，可以参考老罗的系列博客，写的很详细。</p>
<h3 id="0x02-运行时资源寻找过程"><a href="#0x02-运行时资源寻找过程" class="headerlink" title="0x02 运行时资源寻找过程"></a>0x02 运行时资源寻找过程</h3><p>首先我们回想一下在Activity中我们是如何获取定义在strings.xml文件中的字符串的，就是以下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//MainActivity.java</div><div class="line">String str = getResources().getString(R.string.app_string_2_1);</div></pre></td></tr></table></figure>
<p>我们来分析一下调用链，<br>首先getResources()方法是在Context中定义的抽象方法，Context的继承关系如图所示：</p>
<p><img src="http://i4.piimg.com/567571/5a0c8aed9fd9b402.png" alt="Context继承关系"></p>
<p>在Activity中的getResources()方法会走到ContextWrapper的实现上，而ContextWrapper顾名思义它只是一个包装类，最终的调用是ContextWrapper的实际类ContextImpl中的方法。</p>
<p>ContextImpl中getResources()方法返回了它的成员变量mResource,我们看一下ContextImpl的构造函数，其中mResources被第一次赋值是通过下面的函数调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Resources resources = packageInfo.getResources(mainThread);</div></pre></td></tr></table></figure>
<p>packageInfo是一个LoadedApk类型的参数，mainThread是ActivityThread类型的参数，mainThread就是当前Apk运行的主进程类，我们继续看LoadedApk中的方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public Resources getResources(ActivityThread mainThread) &#123;</div><div class="line">    if (mResources == null) &#123;</div><div class="line">        mResources = mainThread.getTopLevelResources(mResDir, mSplitResDirs, mOverlayDirs,</div><div class="line">                mApplicationInfo.sharedLibraryFiles, Display.DEFAULT_DISPLAY, null, this);</div><div class="line">    &#125;</div><div class="line">    return mResources;</div></pre></td></tr></table></figure>
<p>继续往下走到AcitvityThread中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Creates the top level resources for the given package.</div><div class="line"> */</div><div class="line">Resources getTopLevelResources(String resDir, String[] splitResDirs, String[] overlayDirs,</div><div class="line">        String[] libDirs, int displayId, Configuration overrideConfiguration,</div><div class="line">        LoadedApk pkgInfo) &#123;</div><div class="line">    return mResourcesManager.getTopLevelResources(resDir, splitResDirs, overlayDirs, libDirs,</div><div class="line">            displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);</div></pre></td></tr></table></figure>
<p>mResourceManager是一个ResourceManager类型的成员变量，当我们戳开ResourceManager的代码时，惊喜的发现这个类是一个单例，然后定位到getTopLevelResources方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">这个方法有点长，我删减了一些不太关键的逻辑</div><div class="line">ResourcesKey key = new ResourcesKey(resDir, displayId, overrideConfiguration, scale, token);</div><div class="line">Resources r;</div><div class="line">WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);</div><div class="line">r = wr != null ? wr.get() : null;</div><div class="line">if (r != null &amp;&amp; r.getAssets().isUpToDate()) &#123;</div><div class="line">    return r;</div><div class="line">&#125;</div><div class="line">AssetManager assets = new AssetManager();</div><div class="line">if (resDir != null) &#123;</div><div class="line">      if (assets.addAssetPath(resDir) == 0) &#123;</div><div class="line">          return null;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">r = new Resources(assets, dm, config, compatInfo, token);</div><div class="line">WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);</div><div class="line">Resources existing = wr != null ? wr.get() : null;</div><div class="line">if (existing != null &amp;&amp; existing.getAssets().isUpToDate()) &#123;</div><div class="line">    r.getAssets().close();</div><div class="line">    return existing;</div><div class="line">&#125;</div><div class="line">mActiveResources.put(key, new WeakReference&lt;Resources&gt;(r));</div><div class="line">return r;</div></pre></td></tr></table></figure>
<p>最终我们找到了Resources对象创建的地方，接下来我们看获取到Resources后如何找到对应id的资源，在Resources中定位到getString(int id)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@NonNull</div><div class="line">public String getString(@StringRes int id) throws NotFoundException &#123;</div><div class="line">    final CharSequence res = getText(id);</div><div class="line">    if (res != null) &#123;</div><div class="line">        return res.toString();</div><div class="line">    &#125;</div><div class="line">    throw new NotFoundException(&quot;String resource ID #0x&quot;</div><div class="line">                                + Integer.toHexString(id));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着往下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public CharSequence getText(@StringRes int id) throws NotFoundException &#123;</div><div class="line">     CharSequence res = mAssets.getResourceText(id);</div><div class="line">     if (res != null) &#123;</div><div class="line">         return res;</div><div class="line">     &#125;</div><div class="line">     throw new NotFoundException(&quot;String resource ID #0x&quot;</div><div class="line">                                 + Integer.toHexString(id));</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>注意到寻找资源的调用是有AssetManager来执行的。这个AssetManager对象是在ResourceManager中创建并传递给Resources中的，java层的AssetManager只是Native层AssetManager的一个代理，其中初始化，获取资源的方法都是native实现，java层的AssetManager通过持有Native对象的内存地址来和Native对象进行通信。我们再来看ResourceManager中对AssetManager的使用方式，发现ResourceManager只为AssetManager设置了资源路径，这个路径实际就是Apk文件的路径。</p>
<p>分析到这里，我们其实已经找到了在运行时注入资源的方式，有两个思路，第一，当我们需要加载插件中的资源时，替换掉当前Context的ContextImpl中的Resource对象。第二，由于ResourceManager是一个单例类，并且持有了当前App的Resource缓存，那么我们直接在App启动时手动替换掉ResourceManager中的Resource缓存，就可以在当前App中添加插件的资源，并且全局有效。</p>
<h3 id="0x03-实例分析"><a href="#0x03-实例分析" class="headerlink" title="0x03 实例分析"></a>0x03 实例分析</h3><p>下面我们来实验一下刚刚得到思路，这里我们采用第一个思路，也就是只替换当前Context的Resource对象。</p>
<h4 id="创建plugin"><a href="#创建plugin" class="headerlink" title="创建plugin"></a>创建plugin</h4><p>首先创建接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//ILib.java</div><div class="line">public interface ILib &#123;</div><div class="line">    String getLibString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口的实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//LibComponent.java</div><div class="line">public class LibComponent implements ILib&#123;</div><div class="line">    private Context context;</div><div class="line">    public LibComponent(Context context)&#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public String getLibString() &#123;</div><div class="line">        Log.e(&quot;lib_plugin&quot;,Integer.toHexString(R.string.app_1_string));</div><div class="line">        return context.getString(R.string.app_1_string);//输出的内容是&quot;111111ypp1&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="创建host"><a href="#创建host" class="headerlink" title="创建host"></a>创建host</h4><p>App启动时将Asset目录下的插件拷贝到App的存储目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//HostApplication.java</div><div class="line">private void installPluginApk()&#123;</div><div class="line">       new Thread(new Runnable() &#123;</div><div class="line">           @Override</div><div class="line">           public void run() &#123;</div><div class="line">               try &#123;</div><div class="line">                   InputStream inputStream = getResources().getAssets().open(&quot;lib_plugin.apk&quot;);</div><div class="line">                   File apkFile = new File(getFilesDir(),&quot;lib_plugin.apk&quot;);</div><div class="line">                   OutputStream out = new FileOutputStream(apkFile);</div><div class="line">                   byte[] buf = new byte[1024];</div><div class="line">                   int len;</div><div class="line">                   while((len=inputStream.read(buf))&gt;0)&#123;</div><div class="line">                       out.write(buf,0,len);</div><div class="line">                   &#125;</div><div class="line">                   inputStream.close();</div><div class="line">                   out.close();</div><div class="line">                   installSuccess.set(true);</div><div class="line">               &#125;catch (IOException e)&#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">                   installSuccess.set(false);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;).start();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>修改当前Context的Resource，注入插件的资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//MainActivity.java</div><div class="line">private void injectContextResource()&#123;</div><div class="line">    AssetManager assetManager = ReflectAccelerator.newAssetManager();</div><div class="line">    String[] paths = new String[2];</div><div class="line">    paths[0] = getPackageResourcePath();</div><div class="line">    paths[1] = getFilesDir()+File.separator+&quot;lib_plugin.apk&quot;;</div><div class="line">    ReflectAccelerator.addAssetPaths(assetManager,paths);</div><div class="line">    Resources base = getResources();</div><div class="line">    DisplayMetrics displayMetrics = base.getDisplayMetrics();</div><div class="line">    Configuration configuration = base.getConfiguration();</div><div class="line">    Resources injectResource = new Resources(</div><div class="line">            assetManager,</div><div class="line">            displayMetrics,</div><div class="line">            configuration</div><div class="line">            );</div><div class="line">    ReflectAccelerator.setResources(getBaseContext(),injectResource);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建ClassLoader加载插件中的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//MainActivity.java</div><div class="line">private String getLibText()&#123;</div><div class="line">    File source = new File(getFilesDir()+File.separator+&quot;lib_plugin.apk&quot;);</div><div class="line">    DexClassLoader cl = new DexClassLoader(</div><div class="line">            source.getAbsolutePath(),</div><div class="line">            this.getCacheDir().getPath(),</div><div class="line">            null,</div><div class="line">            getClassLoader()</div><div class="line">    );</div><div class="line">    Class libPlugin = null;</div><div class="line">    //省略异常处理</div><div class="line">        libPlugin = cl.loadClass(&quot;com.haizhi.oa.restest.LibComponent&quot;);</div><div class="line">        Class[] paramTypes = new Class[]&#123;</div><div class="line">                Context.class</div><div class="line">        &#125;;</div><div class="line">        Constructor constructor = libPlugin.getConstructor(paramTypes);</div><div class="line">        injectContextResource();//注入资源</div><div class="line">        ILib iLib = (ILib)constructor.newInstance(getBaseContext());</div><div class="line">        String res = iLib.getLibString();</div><div class="line">        return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反射工具类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//ReflectAccelerator.java</div><div class="line">public static AssetManager newAssetManager() &#123;</div><div class="line">       AssetManager assets;</div><div class="line">       try &#123;</div><div class="line">           assets = AssetManager.class.newInstance();</div><div class="line">       &#125; catch (InstantiationException e1) &#123;</div><div class="line">           e1.printStackTrace();</div><div class="line">           return null;</div><div class="line">       &#125; catch (IllegalAccessException e1) &#123;</div><div class="line">           e1.printStackTrace();</div><div class="line">           return null;</div><div class="line">       &#125;</div><div class="line">       return assets;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static int[] addAssetPaths(AssetManager assets, String[] paths) &#123;</div><div class="line">       if (sAssetManager_addAssetPaths_method == null) &#123;</div><div class="line">           sAssetManager_addAssetPaths_method = getMethod(AssetManager.class,</div><div class="line">                   &quot;addAssetPaths&quot;, new Class[]&#123;String[].class&#125;);</div><div class="line">       &#125;</div><div class="line">       if (sAssetManager_addAssetPaths_method == null) return null;</div><div class="line">       return invoke(sAssetManager_addAssetPaths_method, assets, new Object[]&#123;paths&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void setResources(Context context, Resources resources) &#123;</div><div class="line">       if (sContextImpl_mResources_field == null) &#123;</div><div class="line"></div><div class="line">           sContextImpl_mResources_field = getDeclaredField(</div><div class="line">                   context.getClass(), &quot;mResources&quot;);</div><div class="line">           if (sContextImpl_mResources_field == null) return;</div><div class="line">       &#125;</div><div class="line">       setValue(sContextImpl_mResources_field, context, resources);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="资源冲突的现象"><a href="#资源冲突的现象" class="headerlink" title="资源冲突的现象"></a>资源冲突的现象</h4><p>实际运行一下，结果如下：</p>
<p><img src="http://i4.piimg.com/567571/7425928853951073.png" alt=""></p>
<p>呃，非常的尴尬，没有按照我们设想的那样输出”111111ypp1”,这是为什么呢？</p>
<p>猜测一下原因，我们在注入资源的时候放入了两个path路径，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">paths[0] = getPackageResourcePath();</div><div class="line">paths[1] = getFilesDir()+File.separator+&quot;lib_plugin.apk&quot;;</div></pre></td></tr></table></figure>
<p>path[0]是宿主的资源，path[1]是插件资源，假如宿主和插件的资源id相同，由于宿主的资源路径在插件的前面，那么AssetManager会首先命中宿主的资源，于是返回了宿主的资源。<br>我们调整一下path的顺序，验证一下我们的猜测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">paths[1] = getPackageResourcePath();</div><div class="line">paths[0] = getFilesDir()+File.separator+&quot;lib_plugin.apk&quot;;</div></pre></td></tr></table></figure>
<p>调整顺序后，正确返回了插件的资源。</p>
<p><img src="http://i1.piimg.com/567571/bb165e5dccfd9f62.png" alt=""></p>
<p>对比一下插件和宿主的R.java文件，我们发现插件中R.string.app_1_string的资源id是0x7f040000,在宿主中，同样id对应的资源为R.layout.abc_action_bar_title_item 它的值是res/layout/abc_action_bar_title_item，再次验证了我们的猜测。</p>
<h4 id="如何解决资源冲突"><a href="#如何解决资源冲突" class="headerlink" title="如何解决资源冲突"></a>如何解决资源冲突</h4><p>要解决资源冲突，目前有很多插件化框架都提出了自己的解决方案</p>
<ol>
<li>宿主和插件隔离</li>
</ol>
<p>我们在加载插件Activity时，只在当前上下文注入插件的资源，这样宿主和插件之间是完全隔离的，也就无所谓资源id冲突了。</p>
<ol>
<li>通过public.xml锁死宿主资源id</li>
</ol>
<p>在编译宿主时，手动指定宿主中所有资源的id，然后在编译插件时，通过在public.xml中设定padding，避免分配到宿主的资源id</p>
<ol>
<li>修改aapt,增加packageId参数</li>
</ol>
<p>在前文的分析中，我们知道资源id是通过0xPPTTEEEE的形式指定的，如果在编译插件资源时，指定插件的packageId不是0x7f，而是指定的值，那么即使TTEEEE重复，也能保证整个资源id不重复。</p>
<ol>
<li>修改resource.arsc</li>
</ol>
<p>这种方案和第三种是同样的原理，都是修改packageId，只是是从resources.arsc文件出发。</p>
<p>下面我们尝试一下直接修改resource.arsc的方案。由于需要修改aapt生成的R.java文件，因此我们不使用gradle构建，使用appt,javac,dx手动打包。</p>
<p>首先修改R.java,指定packageId为0x7e</p>
<p><img src="http://i1.piimg.com/567571/b57ad2249b26d40a.png" alt=""></p>
<p>然后修改resource.arsc中的packageId</p>
<p><img src="http://i1.piimg.com/567571/434052c0f6b26d50.png" alt=""></p>
<p>解释一下这几个值的含义：</p>
<p><em>Chunk_Type</em> 由于resource.arsc中的内容是分块的，chunk_type表示当前数据块的类型。</p>
<p><em>Header_Size</em> 每一种类型的数据块都有一个头部，header_size表示当前数据块头部的大小</p>
<p><em>Chunk_Size</em> 当前数据块的大小</p>
<p><em>Package_ID</em> 当前package的ID</p>
<p>理论上要修改packageid不仅仅需要修改resources.arsc中的packageid，还要修改所有编译后的xml中的相关内容，这里我们先考虑最简单的情况，在插件资源中只包含values类型。我们将编译好的resource.arsc文件中的0x7f000000修改为0x7e000000。</p>
<p>然后按照正常的步骤打包插件。在宿主中运行，R.string.app_1_string对应的资源id变为0x7e040002,同时正确输出了”111111ypp1”。</p>
<p><img src="http://i1.piimg.com/567571/e892a4b8db6553d4.png" alt=""></p>
<h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>上述的分析其实只回答了我们一个问题，为什么我们在做插件化开发的时候，要对资源id进行特殊的处理。除开宿主和插件隔离的方案，无论是携程的实现还是Small的实现，都采用了手动分配PP段，保证资源id不重复。</p>
<p>我对这个问题的理解是这样的，宿主和插件，插件和插件之间进行资源共享对于插件化开发而言并不是必须的，假设宿主和插件之间隔离，带来的问题是同样的资源会在多个插件中重复出现，导致应用的整体体积膨胀，但是我们可以规避复杂的资源id处理部分，不做，就不会有bug。</p>
<p>如果我们整体采用Small作为我们的插件化框架，就必然要接受Small对于所有插件共享同一个classloader，共享同一个AssetManager的方案，同时要接受Small提供的一系列资源处理的gradle插件，那么Small会做的处理就不仅仅是分配PP段，同时还会对插件进行资源裁剪，过滤掉重复的资源，对依赖裁剪，过滤掉重复的依赖，这些事情当然是非常好的，但是作为一个新的开源框架，直接应用到生产环境是有风险的，我们要对Small的代码有足够深入的理解才能保证在出bug时能够及时修复。</p>
<p>综上，我建议前期我们的插件化开发可以采用宿主和插件隔离的方案规避资源id的问题，把重点放在插件间的通信上，同时确保能够兼容nuwa的热修复框架以及deepLink的schema跳转。这样的方案我们有可能遇到以下的问题，</p>
<ol>
<li>根据Small的wiki，有可能会遇到Activity 主题相关的一系列问题，这个我需要尝试一下。</li>
<li>从现有代码剥离插件的时候需要将模块自有的资源和依赖的公共资源一起剥离到插件工程。这个我可以尝试通过脚本分析代码对资源的引用关系，一定程度上做到自动化。</li>
<li>apk体积膨胀。由于公共资源在插件中被多次打包，会带来apk体积膨胀的问题，这个问题在这种方案下是必然的，也许只能接受。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插件化-资源处理&quot;&gt;&lt;a href=&quot;#插件化-资源处理&quot; class=&quot;headerlink&quot; title=&quot;插件化-资源处理&quot;&gt;&lt;/a&gt;插件化-资源处理&lt;/h2&gt;&lt;p&gt;写的比较长，可以选择跳过前面2节，直接从&lt;strong&gt;0x03实例分析&lt;/strong&gt;开
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列化和反序列化</title>
    <link href="http://yoursite.com/2016/07/06/serializable_parcelable/"/>
    <id>http://yoursite.com/2016/07/06/serializable_parcelable/</id>
    <published>2016-07-06T08:54:15.000Z</published>
    <updated>2016-07-26T07:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><hr>
<h3 id="1-序列化的原因"><a href="#1-序列化的原因" class="headerlink" title="1 序列化的原因"></a>1 序列化的原因</h3><p>java序列化主要是为了跨平台，实现对象的一致性，可在不同的平台上，保持自己原有的属性和方法不变</p>
<h3 id="2-序列化的作用"><a href="#2-序列化的作用" class="headerlink" title="2 序列化的作用"></a>2 序列化的作用</h3><ol>
<li>永久的保存对象数据（将对象数据保存在文件当中，活着是磁盘中）；</li>
<li>在网络上传送对象的字节序列</li>
<li>通过RMI传输对象(不懂，囧)</li>
<li>将对象数据在进程之间进行传递</li>
</ol>
<a id="more"></a>
<h3 id="3-序列化的实现方式"><a href="#3-序列化的实现方式" class="headerlink" title="3 序列化的实现方式"></a>3 序列化的实现方式</h3><h4 id="3-1-实现Serializable接口"><a href="#3-1-实现Serializable接口" class="headerlink" title="3.1 实现Serializable接口"></a>3.1 实现Serializable接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Person implements Serializable &#123;</div><div class="line">	/**</div><div class="line">	 * 序列化id</div><div class="line">	 */</div><div class="line">	private static final long serialVersionUID = 112347861234817234L;</div><div class="line">	private int age;</div><div class="line">	private String name;</div><div class="line">	private String sex;</div><div class="line">	</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	public String getSex() &#123;</div><div class="line">		return sex;</div><div class="line">	&#125;</div><div class="line">	public void setSex(String sex) &#123;</div><div class="line">		this.sex = sex;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class SerializableDemo &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</div><div class="line">		Person person = new Person();</div><div class="line">		person.setName(&quot;周杰伦&quot;);</div><div class="line">		person.setAge(36);</div><div class="line">		person.setSex(&quot;男&quot;);</div><div class="line">		serializablePerson(person);</div><div class="line"></div><div class="line">		Person newPerson = deSerializablePerson();</div><div class="line">		System.err.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;, newPerson.getName(), newPerson.getAge(),</div><div class="line">				newPerson.getSex()));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 序列化对象</div><div class="line">	 * </div><div class="line">	 * @param person</div><div class="line">	 * @throws FileNotFoundException</div><div class="line">	 * @throws IOException</div><div class="line">	 */</div><div class="line">	private static void serializablePerson(Person person) throws FileNotFoundException, IOException &#123;</div><div class="line">		File file = new File(&quot;./person.txt&quot;);</div><div class="line">		if (!file.exists()) &#123;</div><div class="line">			file.createNewFile();</div><div class="line">		&#125;</div><div class="line">		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));</div><div class="line">		oos.writeObject(person);</div><div class="line">		System.out.println(&quot;Person对象序列化成功!&quot;);</div><div class="line">		oos.close();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 反序列化得到对象</div><div class="line">	 * </div><div class="line">	 * @return</div><div class="line">	 * @throws FileNotFoundException</div><div class="line">	 * @throws IOException</div><div class="line">	 * @throws ClassNotFoundException</div><div class="line">	 */</div><div class="line">	private static Person deSerializablePerson() throws FileNotFoundException, IOException, ClassNotFoundException &#123;</div><div class="line">		ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;./person.txt&quot;)));</div><div class="line">		Person person = (Person) ois.readObject();</div><div class="line">		System.out.println(&quot;Person对象反序列化成功!&quot;);</div><div class="line">		return person;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先查看序列化后的文件内容：<br><img src="http://img.blog.csdn.net/20160706170307481" alt="serializable_file"></p>
<p>运行结果：<br><img src="http://img.blog.csdn.net/20160706170359457" alt="serializable_result"></p>
<p>序列化成功后，会在当前类文件目录下生成一个person.txt文件</p>
<p>注释掉序列化代码后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</div><div class="line">//		Person person = new Person();</div><div class="line">//		person.setName(&quot;周杰伦&quot;);</div><div class="line">//		person.setAge(36);</div><div class="line">//		person.setSex(&quot;男&quot;);</div><div class="line">//		serializablePerson(person);</div><div class="line"></div><div class="line">		Person newPerson = deSerializablePerson();</div><div class="line">		System.err.println(MessageFormat.format(&quot;name=&#123;0&#125;,age=&#123;1&#125;,sex=&#123;2&#125;&quot;, newPerson.getName(), newPerson.getAge(),</div><div class="line">				newPerson.getSex()));</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>通过文件，反序列化，结果是：<br><img src="http://img.blog.csdn.net/20160706170427358" alt="serializable_result2"></p>
<p>我们可以看见Person类里面有个<strong><em>serialVersionUID</em></strong>,这个<strong><em>serialVersionUID</em></strong>是用来干什么的？<br>首先我们修改一下<strong><em>serialVersionUID</em></strong>，运行一下demo，看看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.io.InvalidClassException: com.haizhi.Person; local class incompatible: stream classdesc serialVersionUID = 112347861234817234, local class serialVersionUID = 112347861234817235</div><div class="line">	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:617)</div><div class="line">	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1622)</div><div class="line">	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1517)</div><div class="line">	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1771)</div><div class="line">	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1350)</div><div class="line">	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370)</div><div class="line">	at com.haizhi.SerializableDemo.deSerializablePerson(SerializableDemo.java:55)</div><div class="line">	at com.haizhi.SerializableDemo.main(SerializableDemo.java:21)</div></pre></td></tr></table></figure>
<p>报了一个异常，说明反序列化失败；</p>
<p>Java序列化机制会根据serialVersionUID作序列化版本比较，反序列化时，如果发现序列化数据里面的serialVersionUID与model类的serialVersionUID不同，就会导致反序列化失败，出现序列化版本不一致的异常；</p>
<p>当实现Serializable接口的实体类没有显示定义serialVersionUID，serialVersionUID对类的详细信息具有较高的敏感性，一个空格的修改就会导致serialVersionUID的变化，Java序列化机制会根据编译器实现的不同可能千差万别，这样在反序列化过程可能会导致意外的 InvalidClassException；</p>
<p>为了保证serialVersionUID在不同java编译器实现的一致性，为了实现序列化接口的实体能够兼容先前版本，强烈建议显示声明serialVersionUID；</p>
<p>显式地定义serialVersionUID有两种用途：</p>
<ol>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li>
<li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</li>
</ol>
<h4 id="3-2-实现Parcelable接口"><a href="#3-2-实现Parcelable接口" class="headerlink" title="3.2 实现Parcelable接口"></a>3.2 实现Parcelable接口</h4><p>Parcelabel 的实现，需要在类中添加一个静态成员变量 CREATOR，这个变量需要继承 Parcelable.Creator 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public class Student implements Parcelable&#123;</div><div class="line">    private int name;</div><div class="line">    private String grade;</div><div class="line">    private int score;</div><div class="line">    public Students(Parcel source)&#123;</div><div class="line">    	name = sourece.readString();</div><div class="line">    	grade = source.readString();</div><div class="line">        score = source.readInt();</div><div class="line">    &#125;</div><div class="line">    public int getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public String getGrade() &#123;</div><div class="line">        return grade;</div><div class="line">    &#125;</div><div class="line">    public void setGrade(String grade) &#123;</div><div class="line">        this.grade = grade;</div><div class="line">    &#125;</div><div class="line">    public int getScore()&#123;</div><div class="line">    	return score;</div><div class="line">    &#125;</div><div class="line">    public void setScore(int score)&#123;</div><div class="line">    	this.score = score;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int describeContents() &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line">        dest.writeString(name);</div><div class="line">        dest.writeString(grade);</div><div class="line">        dest.writeInt(score);</div><div class="line">    &#125;</div><div class="line">    //Interface that must be implemented and provided as a public CREATOR field that generates instances of your Parcelable class from a Parcel. </div><div class="line">    public final static Parcelable.Creator&lt;Students&gt; CREATOR = new Parcelable.Creator&lt;Students&gt;() &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Students createFromParcel(Parcel source) &#123;</div><div class="line">            // TODO Auto-generated method stub</div><div class="line">            return new Students(source);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Students[] newArray(int size) &#123;</div><div class="line">            // TODO Auto-generated method stub</div><div class="line">            return new Students[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-把对象包装成JSON字符串传输"><a href="#3-3-把对象包装成JSON字符串传输" class="headerlink" title="3.3 把对象包装成JSON字符串传输"></a>3.3 把对象包装成JSON字符串传输</h4><h3 id="4-序列化比较"><a href="#4-序列化比较" class="headerlink" title="4 序列化比较"></a>4 序列化比较</h3><p>1、在使用内存的时候Parcelable比Serializable的性能高；</p>
<p>2、Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC（内存回收）；</p>
<p>3、Parcelable不能使用在将对象存储在磁盘上这种情况，因为在外界的变化下Parcelable不能很好的保证数据的持续性；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-序列化的原因&quot;&gt;&lt;a href=&quot;#1-序列化的原因&quot; class=&quot;headerlink&quot; title=&quot;1 序列化的原因&quot;&gt;&lt;/a&gt;1 序列化的原因&lt;/h3&gt;&lt;p&gt;java序列化主要是为了跨平台，实现对象的一致性，可在不同的平台上，保持自己原有的属性和方法不变&lt;/p&gt;
&lt;h3 id=&quot;2-序列化的作用&quot;&gt;&lt;a href=&quot;#2-序列化的作用&quot; class=&quot;headerlink&quot; title=&quot;2 序列化的作用&quot;&gt;&lt;/a&gt;2 序列化的作用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;永久的保存对象数据（将对象数据保存在文件当中，活着是磁盘中）；&lt;/li&gt;
&lt;li&gt;在网络上传送对象的字节序列&lt;/li&gt;
&lt;li&gt;通过RMI传输对象(不懂，囧)&lt;/li&gt;
&lt;li&gt;将对象数据在进程之间进行传递&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
</feed>
